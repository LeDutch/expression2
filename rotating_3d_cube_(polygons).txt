@name Rotating 3D Cube - Bob Tomato
@inputs EGP:wirelink
@persist [Vertices Faces VisibleFaces Pokemon]:table [AngleX AngleY AngleZ Speed Offset]:number Spritesheet:string
@strict

if (first()) {
    EGP:egpClear()
    tauPrecacheMaterial("3861508")
    
    # Setting global vars
    Spritesheet = "../data/tau/cache/files/1a2b6f5882d9172b9d6ab62bdf263c91.png"
    Vertices = table(
        array(-100, -100, -100), array(100, -100, -100),
        array(100, 100, -100), array(-100, 100, -100),
        array(-100, -100, 100), array(100, -100, 100),
        array(100, 100, 100), array(-100, 100, 100)
    )

    Faces = table(
        array(1, 4, 3, 2), array(5, 6, 7, 8),
        array(1, 5, 8, 4), array(2, 3, 7, 6),
        array(4, 8, 7, 3), array(1, 2, 6, 5)
    )
    VisibleFaces = table()
    Pokemon = table()

    AngleX = 0
    AngleY = 0
    AngleZ = 0
    Speed = 100
    Offset = 250
}

function array rotate(X:number, Y:number, Z:number, Ax:number, Ay:number, Az:number) {
    let Rx = Ax * (_PI / 180), Ry = Ay * (_PI / 180), Rz = Az * (_PI / 180)
    let CosX = cos(Rx), SinX = sin(Rx)
    let CosY = cos(Ry), SinY = sin(Ry)
    let CosZ = cos(Rz), SinZ = sin(Rz)

    let Y1 = Y * CosX - Z * SinX, Z1 = Y * SinX + Z * CosX
    let X1 = X * CosY + Z1 * SinY, Z2 = -X * SinY + Z1 * CosY
    let X2 = X1 * CosZ - Y1 * SinZ, Y2 = X1 * SinZ + Y1 * CosZ

    return array(X2, Y2, Z2)
}

function number getInitialIndexForFace(Face:number) {
    return (Face - 1) * 3 + 1
}

function void wirelink:initSpriteFace(Id:number, Image:string) {
    This:egpMaterial(Id, Image)
}

function void wirelink:updateSpriteFace(Id:number, FaceVerts:array, SpriteIndex:number, UV:vector2) {
    let Padding = 0.05

    let Cols = floor(1 / UV:x())
    let X = floor((SpriteIndex - 1) % Cols)
    let Y = floor((SpriteIndex - 1) / Cols)

    let U0 = (X + Padding) * UV:x()
    let V0 = (Y + Padding) * UV:y()
    let U1 = (X + 1 - Padding) * UV:x()
    let V1 = (Y + 1 - Padding) * UV:y()

    let UVMapped = array(
        vec4(FaceVerts[1, vector2]:x(), FaceVerts[1, vector2]:y(), U0, V0),
        vec4(FaceVerts[2, vector2]:x(), FaceVerts[2, vector2]:y(), U1, V0),
        vec4(FaceVerts[3, vector2]:x(), FaceVerts[3, vector2]:y(), U1, V1),
        vec4(FaceVerts[4, vector2]:x(), FaceVerts[4, vector2]:y(), U0, V1)
    )

    This:egpPoly(Id + 10, FaceVerts)
    This:egpPoly(Id, UVMapped)
}

function vector cross(A:vector, B:vector) {
    return vec(
        A:y() * B:z() - A:z() * B:y(),
        A:z() * B:x() - A:x() * B:z(),
        A:x() * B:y() - A:y() * B:x()
    )
}

function vector faceNormal(A:array, B:array, C:array) {
    let AB = vec(B[1,number]-A[1,number], B[2,number]-A[2,number], B[3,number]-A[3,number])
    let BC = vec(C[1,number]-B[1,number], C[2,number]-B[2,number], C[3,number]-B[3,number])
    return cross(AB, BC):normalized()
}

function number dot(A:vector, B:vector) {
    return A:x() * B:x() + A:y() * B:y() + A:z() * B:z()
}

function rotation3D() {
    AngleX += Speed
    AngleY += Speed
    AngleZ += Speed

    let LightDir = vec(0, -1, 1):normalized()
    let RotatedVerts = table()

    for (K = 1, Vertices:count()) {
        let V = Vertices[K, array]
        RotatedVerts[K, array] = rotate(V[1,number], V[2,number], V[3,number], AngleX, AngleY, AngleZ)
    }

    let FaceDepths = table()
    let DepthIndex = 0

    for (I = 1, Faces:count()) {
        let Face = Faces[I, array]
        let ProjectedVerts = array()
        let ZSum = 0

        for (J = 1, 4) {
            let V = RotatedVerts[Face[J, number], array]
            ProjectedVerts:pushVector2(vec2(V[1,number] + Offset, V[2,number] + Offset))
            ZSum += V[3, number]
        }

        let Area = 0
        for (J = 1, 4) {
            let A = ProjectedVerts[J, vector2], B = ProjectedVerts[(J % 4) + 1, vector2]
            Area += (A:x() * B:y()) - (B:x() * A:y())
        }

        if (Area < 0) {
            if (VisibleFaces[I, number]) {
                VisibleFaces[I, number] = 0
                EGP:egpAlpha(100 + I, 0)
                EGP:egpAlpha(110 + I, 0)
            }
            continue
        }
        elseif (!VisibleFaces[I, number]) {
            VisibleFaces[I, number] = 1
        }
        
        EGP:initSpriteFace(100 + I, Spritesheet)

        DepthIndex += 1
        FaceDepths[DepthIndex, table] = table("index" = I, "z" = ZSum / 4, "points" = ProjectedVerts)
    }

    for (I = 1, FaceDepths:count() - 1) {
        for (J = I + 1, FaceDepths:count()) {
            if (FaceDepths[I, table]["z", number] < FaceDepths[J, table]["z", number]) {
                let Temp = FaceDepths[I, table]
                FaceDepths[I, table] = FaceDepths[J, table]
                FaceDepths[J, table] = Temp
            }
        }
    }

    for (K = 1, FaceDepths:count()) {
        let FaceIndex = FaceDepths[K, table]["index", number]
        let Points = FaceDepths[K, table]["points", array]
        let Face = Faces[FaceIndex, array]

        let N = faceNormal(
            RotatedVerts[Face[1, number], array],
            RotatedVerts[Face[2, number], array],
            RotatedVerts[Face[3, number], array]
        )

        let Bright = clamp(dot(N, LightDir), 0, 1)
        let Intensity = Bright * 205 + 50

        EGP:egpColor(100 + FaceIndex + 10, vec(Intensity, Intensity * 0.9, Intensity * 0.3))
        EGP:egpAlpha(100 + FaceIndex + 10, 255)
        EGP:egpAlpha(100 + FaceIndex, Intensity)
        
        let SpriteIndex = Pokemon[FaceIndex, number]

        EGP:updateSpriteFace(100 + FaceIndex, Points, SpriteIndex, vec2(64,64) / vec2(1024,1024))
    }
}

function start() {
    rotation3D()
    for (I = 1, Faces:count()) {
        Pokemon[I, number] = getInitialIndexForFace(I)
        VisibleFaces[I, number] = 0
    }
    timer(1, 0, function() {
        for (I = 1, Faces:count()) {
            let Base = getInitialIndexForFace(I)
            let Index = Pokemon[I, number]
    
            Index += 1
            if (Index > Base + 2) { Index = Base }
    
            Pokemon[I, number] = Index
        }
    })
    timer(0.1, 0, function() {
        rotation3D()
    })
    
}

if (first()) {
    start()
}

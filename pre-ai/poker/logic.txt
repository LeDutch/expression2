@name Tomato Poker Logic
@persist [Players CommunityCards Deck AllIn]:table
@persist [GameState CoinSeat BuyIn InPlay ActionSeat Pot CurrentBet MinBet]:number
@persist [Prefix PrefixColour]:string
@persist [SeatsInPlay]:array

#include "lib/tomato/1.1/tomato_ui"
#include "lib/tomato/1.1/tomato_core"
#include "tomato/poker/graphics"

Players = table()
CommunityCards = table()
AllIn = table()
Deck = table()
SeatsInPlay = array()
GameState = 0
CoinSeat = 0
ActionSeat = 0
CurrentBet = 0
Pot = 0
MinBet = 0
BuyIn = 100000

# =================== Poker Helper Functions =============== #

function array sortAscending(Array:array) {
    for (I = 1, Array:count() - 1) {
        for (J = I + 1, Array:count()) {
            let A = Array[J, number]
            let B = Array[I, number]
            if (A < B) {
                let Temp = Array[I, number]
                Array[I] = Array[J, number]
                Array[J] = Temp
            }
        }
    }
    return Array
}

function number indexOf(Value:string, Array:array) {
    for (Index = 1, Array:count()) {
        if (Array[Index, string] == Value) {
            return Index
        }
    }
    return 0
}


# =================== Poker Logic Functions ================ #

function void assignCoin() {
    let NextCoinSeat = function(Sorted:array, CoinSeat:number) {
        return Sorted[(Sorted:indexOf(CoinSeat) % Sorted:count()) + 1, number]
    }
    if (!CoinSeat) {
        CoinSeat = SeatsInPlay[randint(1, SeatsInPlay:count()), number]
        Players:keys():msgAll("Dealercoin assigned randomly.")
    }
    else {
        CoinSeat = NextCoinSeat(SeatsInPlay, CoinSeat)[number]
        drawDealerCoin(CoinSeat)
    }
    return
}

function void revealHand(PlayerID:string) {
    let HandtoString = function(Cards:table) {
        let CardsString = ""
        foreach (Index:number, Card:table = Cards) {
            CardsString += Card["toString", function]()[string]
            if (Index < Cards:count()) {
                CardsString += ", "
            }
        }
        return CardsString
    }
    let RevealedPlayer = Players[PlayerID, table]
    let Hand = HandtoString(RevealedPlayer["Cards", table])[string]
    let Entity = RevealedPlayer["Entity", entity]
    let Name = Entity:isValid() ? Entity:name() : "Player " + PlayerID
    Players:keys():msgAll((Name + " revealed " + Hand))
}

# =================== Poker Core Functions ================= #

function table evaluateHand(Player:table) {
    if (!Player["InPlay", number]) {
        return table("Points"=0, "Description"="folded.", "HighCards"=array())
    }
    let PlayerCards = Player["Cards", table]
    let OrderedRanks = array("2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A")
    
    # Helper function to combine PlayerCards hand and community cards
    let Concat = function(Table1:table, Table2:table) {
        let Primary = Table1:clone()
        foreach(_:number, Value:table = Table2) {
            Primary:pushTable(Value)
        }
        return Primary
    }
    
    let Cards = Concat(PlayerCards, CommunityCards)[table]
    let Suits = table()
    let Ranks = table()

    # Populate the suits and ranks frequency tables
    foreach(_:number, Card:table = Cards) {
        let Suit = Card["Suit", string]
        let Rank = Card["Rank", string]
        
        Suits[Suit] = Suits[Suit, number] + 1
        Ranks[Rank] = Ranks[Rank, number] + 1
    }
    
    
    # isStraight helper function
    let IsStraight = function(Ranks:table) {
        let Indices = array()
        foreach(_:number, Rank:string = OrderedRanks) {
            if (Ranks[Rank, number]) {
                Indices:pushNumber(OrderedRanks:indexOf(Rank))
            }
        }
        
        for (I = 1, Indices:count() - 4) {
            if (Indices[I + 4, number] - Indices[I, number] == 4) {
                return OrderedRanks[Indices[I + 4, number], string]
            }
        }
        return ""
    }
    
    # Sort for Strings - Helper function
    let SortDescending = function(Array:array) {
        let RankAdjust = function(String:string) {
            let Number = String:toNumber()
            switch (String) {
                case "A",
                    Number = 13
                break
                case "K",
                    Number = 12
                break
                case "J",
                    Number = 11
                break
                default,
                break
            }
            return Number
        }
        for (I = 1, Array:count() - 1) {
            for (J = I + 1, Array:count()) {
                let A = RankAdjust(Array[J, string])[number]
                let B = RankAdjust(Array[I, string])[number]
                if (A > B) {
                    let Temp = Array[I, string]
                    Array[I] = Array[J, string]
                    Array[J] = Temp
                }
            }
        }
        return Array
    }

    # Check for flush and assign the highest rank in the flush
    let FlushRank = ""
    let FlushSuit = ""
    foreach(Suit:string, Count:number = Suits) {
        if (Count >= 5) {
            # Collect cards of the flush suit
            let FlushCards = array()
            FlushSuit = Suit
            foreach(_:number, Card:table = Cards) {
                if (Card["Suit", string] == Suit) {
                    FlushCards:pushString(Card["Rank", string])
                }
            }
    
            # Sort FlushCards to find the highest rank
            FlushCards = SortDescending(FlushCards)[array]
            FlushRank = FlushCards[1, string] # Assign the highest rank
            break
        }
    }

    # Check for straight flush and royal flush
    if (FlushSuit != "") {
        let FlushRanks = table()
        foreach(_:number, Card:table = Cards) {
            if (Card["Suit", string] == FlushSuit) {
                FlushRanks[Card["Rank", string]] = 1
            }
        }
        let HighestCardInStraight = IsStraight(FlushRanks)[string]
        if (HighestCardInStraight != "") {
            if (HighestCardInStraight == "A") {
                return table("Points"=10, "Description"="Royal Flush", "HighCards"=table("A"))
            }
            return table("Points"=9, "Description"="Straight Flush", "HighCards"=table(HighestCardInStraight))
        }
    }

    # Other hands: Four of a kind, full house, etc.
    let FourKind = ""
    let ThreeKind = ""
    let PairRanks = array() # Array to track all pairs
    let Kickers = array()
    let HighestStraight = IsStraight(Ranks)[string]
    
    # Evaluate Ranks
    foreach(Rank:string, Count:number = Ranks) {
        if (Count == 4) {
            FourKind = Rank
        } elseif (Count == 3) {
            ThreeKind = Rank
        } elseif (Count == 2) {
            PairRanks:pushString(Rank) # Track all pairs
        }
        else {
            Kickers:pushString(Rank)
        }
    }
    
    # Sort PairRanks in descending order for tie-breaking
    PairRanks = SortDescending(PairRanks)[array]
    let SortedKickers = SortDescending(Kickers)[array]
    
    if (FourKind != "") {
        return table("Points"=8, "Description"="Four of a Kind", "HighCards"=array(FourKind):add(SortedKickers))
    }
    if (ThreeKind != "" && PairRanks:count() > 0) {
        return table("Points"=7, "Description"="Full House", "HighCards"=array(ThreeKind, PairRanks[1, string]))
    }
    if (FlushRank != "") {
        return table("Points"=6, "Description"="Flush", "HighCards"=array(FlushRank))
    }
    if (HighestStraight != "") {
        return table("Points"=5, "Description"="Straight", "HighCards"=array(HighestStraight))
    }
    if (ThreeKind != "") {
        return table("Points"=4, "Description"="Three of a Kind", "HighCards"=array(ThreeKind):add(SortedKickers))
    }
    if (PairRanks:count() >= 2) {
        let HighPair = PairRanks[1, string]
        return table("Points"=3, "Description"="Two Pair", "HighCards"=array(HighPair):add(SortedKickers))
    }
    if (PairRanks:count() == 1) {
        let HighPair = PairRanks[1, string]
        return table("Points"=2, "Description"="One Pair", "HighCards"=array(HighPair):add(SortedKickers))
    }

    # If other checks fail, detect the high card
    for (Index = OrderedRanks:count(), 1, -1) {
        let Rank = OrderedRanks[Index, string]
        if (Ranks[Rank, number]) {
            return table("Points"=1, "Description"="High Card", "HighCards"=array(Rank):add(SortedKickers))
        }
    }

    return table("Points"=0, "Description"="No Hand", "HighCards"=array())
}

function string bet(Player:table) {
    let Seat = Player["Seat", number]
    let Entity = Player["Entity", entity]
    let Chips = Player["Chips", number]
    let PlayerBet = Player["CurrentBet", number]
    let Amount = abs(CurrentBet - PlayerBet)
    if (Chips - Amount < 0) {  # All in bets
        Pot+=Chips
        Player["Chips", number] = 0
        Player["CurrentBet", number] = Chips
        if(CurrentBet < Chips) {
            CurrentBet = Chips
        }
        AllIn:pushTable(Player)
    }
    else {
        Pot+=Amount
        Player["Chips", number] = Chips - Amount
        Player["CurrentBet", number] = CurrentBet
    }
    Player["TotalBet", number] = Player["TotalBet", number] + Player["CurrentBet", number]
    Player["Action", number] = 1
    timer(0, function() {
        #drawCurrentBet(Seat, Player["CurrentBet", number])
        #drawChips(Seat, Player["Chips", number])

    })
    return Entity:isValid() ? Entity:name() : "Player " + toString(Seat)
}

function void foldHand(Seat:number) {
    let Name = "Player " + Seat
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == Seat) {
            Player["InPlay", number] = 0
            let Entity = Player["Entity", entity]
            if (Entity != _NO_ENTITY) {
                Name = Entity:name()
            }
        }
    }
    
    Players:keys():msgAll(Name + " has folded.")
    for (I=1, 2) {
        fadeOut(Seat + "Card"+I, 0.5)
        fadeOut(Seat + "Card"+I+"_border", 0.5)
    }
}

function void checkOrCall(Seat:number) {
    let Name = "Player " + Seat
    let Description = CurrentBet ? "called $" + CurrentBet : "checked."
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == Seat) {
            Name = bet(Player)
            if(Player["Chips", number] < CurrentBet) {
                Description = "went all in (" + Player["Chips", number]+")."
            }
        }
    }
    Players:keys():msgAll(Name + " has " + Description)
    if (CurrentBet) {
        soundPlay(2,0.3,"pcasino/chip/chip_2.wav")
    }
}

function void raise(Seat:number, Amount:number) {
    CurrentBet = Amount
    let Description = "raised $" + CurrentBet
    let Name = "Player " + Seat
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == Seat) {
            Name = bet(Player)
            if(Player["Chips", number] < CurrentBet) {
                Description = "went all in (" + Player["CurrentBet", number]+")."
            }
        }
        else {
            Player["Action", number] = 0
        }
    }
    Players:keys():msgAll(Name + " has " + Description)
    soundPlay(2,0.3,"pcasino/chip/chip_1.wav")
}

function void blind(Seat:number, Amount:number) {
    CurrentBet = Amount
    let Name = "Player " + Seat
    let Blind = Amount == MinBet ? "big" : "small"
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == Seat) {
            Name = bet(Player)
            Player["Action", number] = 0
        }
    }
    Players:keys():msgAll(Name + " has paid the " + Blind + " blind.")
    soundPlay(2,0.3,"pcasino/chip/chip_2.wav")
}

function payWinners(Winners:table) {
    # Calculate total side pots and remaining pot
    let SidePots = 0
    let TotalPot = Pot

    # Helper function to find and update player information
    let UpdatePlayerChips = function(Seat:number, Payout:number) {
        foreach(_:string, Player:table = Players) {
            if (Player["Seat", number] == Seat) {
                let Entity = Player["Entity", entity]
                Player["Chips", number] = Player["Chips", number] + Payout
                #drawChips(Seat, Player["Chips", number])
                return Entity:isValid() ? Entity:name() : "Player " + Seat
            }
        }
        return "Player " + Seat # Default to generic name
    }

    if (Winners:count() > 1) {
        foreach(_:string, Winner:table = Winners) {
            let MaxPot = Winner["MaxPot", number]
            if (MaxPot) {
                SidePots++
                TotalPot -= MaxPot
            }
        }
    
        # Distribute winnings
        foreach(_:string, Winner:table = Winners) {
            let Seat = Winner["Seat", number]
            let MaxPot = Winner["MaxPot", number]
            let Payout = MaxPot ? MaxPot : floor(TotalPot / (Winners:count() - SidePots))
    
            # Update chips and get player name
            let Name = UpdatePlayerChips(Seat, Payout)[string]
    
            # Announce the winner
            Players:keys():msgAll(Name + " has won " + abbreviateNum(Payout))
        }
    }
    else {
        let Seat = Winners[1, table]["Seat", number]
        let Payout = TotalPot
    
        # Update chips and get player name
        let Name = UpdatePlayerChips(Seat, Payout)[string]
    
        # Announce the winner
        Players:keys():msgAll(Name + " has won " + abbreviateNum(Payout))
    }

    # Reset the pot
    Pot = 0
}

function array seatsInPlay() {
    let Array = array()
    foreach(_:string, Player:table = Players) {
        if(Player["InPlay", number]) {
            let Seat = Player["Seat", number]
            Array:pushNumber(Seat)
        }
    }
    return Array
}

function table:removePlayer(Seat:number) {
    let GetEntity = function() {
        foreach(_:string, Player:table = This) {
            if (Player["Seat", number] == Seat) {
                return Player["Entity", entity]
            }
        }
        return _NO_ENTITY
    }
    let Entity = GetEntity()[entity]
    foreach(Steam:string, Player:table = This) {
        if (Entity:isValid()) {
            Player["Entity", entity]:msg(Entity:name() + " has left the table.")
        }
        else {
            Player["Entity", entity]:msg("Player " + Seat + " has left the table.")
        }
        if (Player["Seat", number] == Seat) {
            This:removeTable(Steam)
            drawEmptySeat(Seat)
        }
    }
}

function void newAction() {
    let Count = SeatsInPlay:count()
    
    # Recursive Lambda to filter out folded players
    let FindNextAction = function() {}
    FindNextAction = function(ActionSeat:number) {
        let Index = SeatsInPlay:indexOf(ActionSeat)
        ActionSeat = SeatsInPlay[Index % Count + 1, number]
        foreach(_:string, Player:table = Players) {
            if (ActionSeat == Player["Seat", number]) {
                if (Player["InPlay", number]) {
                    return ActionSeat
                }
                else {
                    return FindNextAction(ActionSeat)[number]
                }
            }
        }
        return 0
    }
    let HasActioned = function(Seat:number) {
        foreach(_:string, Player:table = Players) {
            if(Player["Seat", number] == Seat) {
                return Player["Action", number]
            }
        }
        return 0
    }
    ActionSeat = FindNextAction(ActionSeat)[number]
    if(!HasActioned(ActionSeat)[number]) {
        print(ActionSeat)
        drawButtons(ActionSeat, CurrentBet)
    }
}

# Function to progress the game
function string updateGameState() {
    GameState++
    let States = array("Pre-Flop", "Flop", "Turn", "River", "Showdown")
    let NewState = States[GameState, string]
    
    #Local helper functions
    let Header = function(Text:string) {
        return "=== " + Text + " ==="
    }
    
    let DealHand = function(Player:table) {
        for (_=1, 2) {
            let Card = Deck["draw", function]()[table]
            Player["Cards", table]:pushTable(Card)
            Player["Entity", entity]:msg("You were dealt: " + Card["toString", function]()[string])
        }
    }
    
    let CommunityToString = function() {
        let String = ""
        let Count = CommunityCards:count()
        foreach(Index:number, Card:table = CommunityCards) {
            String += Card["toString", function]()[string]
             if (Count > 1 && Index < Count) {
                String += ", "
            }
        }
        return String
    }
    
    let ResetBoard = function() {
        # Kick Players with no chips
        foreach(_:string, Player:table = Players) {
            if (Player["Chips", number] == 0) {
                let SeatNum = Player["Seat", number]
                #deletePlayer(SeatNum)
                #drawEmptySeat(SeatNum)
                Players:removePlayer(SeatNum)
            }
        }
        # Reset board
        ActionSeat = 0
        CurrentBet = 0
        Pot = 0
        InPlay = 0
        #updatePot()
        stoptimer("action")
        stoptimer("fold")
        timer(3, function() {
            timer(5, function() {
                InPlay = 1
                GameState = 0
                updateGameState()
            })
        })
    }

    let Action = function() {
        # Timer animation for Player to make a move. 
        drawButtons(ActionSeat, 0)
        let HasActioned = function(Seat:number) {
            foreach(_:string, Player:table = Players) {
                if(Player["Seat", number] == Seat) {
                    return Player["Action", number]
                }
            }
            return 0
        }
        let RestartTimer = function(Name:string, Delay:number, Function:function) {
            if(timerExists(Name)) {
                timerRestart(Name)
                timerAdjust(Name, Delay, 1)
            }
            else {
                timer(Name, Delay, function() {
                    Function()
                })
            }
        }
        let ActionAnimation = function() {}
        SeatsInPlay = sortAscending(seatsInPlay())
        ActionAnimation = function() {
            if (InPlay) {
                if((seatsInPlay()):count() == 1) {
                    # Insert winning logic here
                    newAction()
                    payWinners(
                        table(
                            table("Seat" = ActionSeat, "MaxPot" = 0)
                        )
                    )
                    ResetBoard()
                }
                elseif(!HasActioned(ActionSeat)[number]) {
                    RestartTimer("action", 16, function() {ActionAnimation()})
                    RestartTimer("fold", 15, function() {
                        foldHand(ActionSeat)
                        timer(1.2, function() {
                            newAction()
                        })
                    })
                }
                else {
                    stoptimer("action")
                    stoptimer("fold")
                    #updatePot()
                    updateGameState()
                }
            }
        }
        timer("action", 19, function() {
            ActionAnimation()
        })
        timer("fold", 17, function() {
            foldHand(ActionSeat)
            timer(1.2, function() {
                newAction()
            })
        })
    }

    let SetAction = function() {
        #[
        Pre-Flop
            The action starts with the player sitting to the left of the big blind.
        Post-Flop (and Subsequent Betting Rounds)
            The action starts with the player sitting to the left of the dealer button, if they are still in the hand.
        Special Cases
            In heads-up play (two players), the small blind acts first pre-flop, but the big blind acts first post-flop.
        ]#
        
        CurrentBet = 0
        foreach(_:string, Player:table = Players) {
            Player["Action", number] = 0
            Player["CurrentBet", number] = 0
        }
        foreach(PlayerID:string, _:table = AllIn) {
            let Player = Players[PlayerID, table]
            let TotalBet = Player["TotalBet", number]
            Player["MaxPot", number] = TotalBet*seatsInPlay():count()
        }
        AllIn=table()
        let PreFlop = function(Sorted:array, Index:number) {
            let Count = Sorted:count()
            return Sorted[(Index + 2) % Count + 1, number]
        }
        let PostFlop = function(Sorted:array, Index:number) {
            let Count = Sorted:count()
            return Sorted[Index % Count + 1, number]
        }
        let Index = SeatsInPlay:indexOf(CoinSeat)
        let Count = SeatsInPlay:count()
        if(SeatsInPlay:count() > 2) {
            if (NewState == "Pre-Flop") {
                # Pre-Flop
                CurrentBet = MinBet
                let SmallBlind = MinBet/2
                blind(SeatsInPlay[Index % Count + 1, number], SmallBlind)
                blind(SeatsInPlay[(Index + 1) % Count + 1, number], MinBet)
                ActionSeat = PreFlop(SeatsInPlay, Index)[number]
            }
            else {
                # Post-Flop
                ActionSeat = PostFlop(SeatsInPlay, Index)[number]
            }
        }
        else {
            # Special cases
            if (NewState == "Pre-Flop") {
                # Pre-Flop
                let SmallBlind = MinBet/2
                ActionSeat = CoinSeat
                blind(ActionSeat, SmallBlind)
                blind(SeatsInPlay[Index % Count + 1, number], MinBet)
            }
            else {
                # Post-Flop
                ActionSeat = PostFlop(SeatsInPlay, Index)[number]
            }
        }
        timer(1, function() {
            Action()
        })
    }
    
    let Draw_Community = function(Num:number) {
        let Name = array("Flop1", "Flop2", "Flop3", "Turn", "River")[Num, string]
        let Card = Deck["draw", function]()[table]
                    
        CommunityCards:pushTable(Card)
        drawCommunityCard(Name, Card)
    }
    
    let Notify_Player = function(Player:table) {
        let PlayerEntity = Player["Entity", entity]
        PlayerEntity:msg(Header(NewState)[string])
        if (PlayerEntity:isValid()) {
            let Cards = CommunityToString()[string]
            if (Cards != "") {
                let EvaluatedHand = evaluateHand(Player)
                let Description = EvaluatedHand["Description", string]:lower()
                PlayerEntity:msg(Cards)
                PlayerEntity:msg("You have " + Description)
            }
        }
    }
    
    switch(NewState) {
        case "Pre-Flop",
            CommunityCards = table()
            Deck["initialize", function]()
            Deck["shuffle", function]()
            foreach(_:string, Player:table = Players) {
                Player["InPlay", number] = 1
                Player["Cards", table] = table()
                DealHand(Player)
                Notify_Player(Player)
            }
            SeatsInPlay = sortAscending(seatsInPlay())
            assignCoin()
            dealHands(SeatsInPlay)
            timer(6, function() {
                SetAction()
            })
        break
        case "Flop",
            let Num = 1
            let Deal3Cards = function() {}
            Deal3Cards = function(Num:number) {
                Draw_Community(Num)
                if (Num <= 2) {
                    Num++
                    timer(0.2, function() { Deal3Cards(Num) }) 
                    # Pass the function reference explicitly
                }
                else {
                    foreach(_:string, Player:table = Players) {
                        Notify_Player(Player)
                    }
                    SetAction()
                }
            }
            Deal3Cards(Num)
        break
        case "Turn",
        case "River",
            let Index = NewState == "Turn" ? 4 : 5
            let Card = Deck["draw", function]()[table]
            
            CommunityCards:pushTable(Card)
            Draw_Community(Index)
            foreach(_:string, Player:table = Players) {
                Notify_Player(Player)
            }
            SetAction()
        break
        case "Showdown",
            GameState = 0
            if(CommunityCards:count() != 5) {
                timer(0.5, function() {
                    updateGameState()
                })
                return ""
            }
            let OrderedRanks = array("2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A")
            let BestHand = table("Points"=0, "HighCards"=array())
            let Winners = array()
        
            foreach(PlayerID:string, Player:table = Players) {
                let EvaluatedHand = evaluateHand(Player)
        
                # Check if the current hand is better than the best hand so far
                if (EvaluatedHand["Points", number] > BestHand["Points", number]) {
                    BestHand = EvaluatedHand
                    Winners = array(PlayerID) # Update the winner list to the current player
                } 
                # If hand ranks are the same, compare the top 5 cards
                elseif (EvaluatedHand["Points", number] == BestHand["Points", number]) {
                    let BestCards = BestHand["HighCards", array]
                    let CurrentBestCards = EvaluatedHand["HighCards", array]
                    let Tie = 1 # Assume a tie unless proven otherwise
        
                    foreach(Index:number, HighCard:string = BestCards) {
                        let BestRank = indexOf(HighCard, OrderedRanks)
                        let CurrentRank = indexOf(CurrentBestCards[Index, string], OrderedRanks)
                    
                        if (CurrentRank > BestRank) {
                            BestHand = EvaluatedHand
                            Winners = array(PlayerID) # Update winner list to the current player
                            Tie = 0 # Break tie
                            break
                        } elseif (CurrentRank < BestRank) {
                            Tie = 0 # Current player loses; no need to add them as a winner
                            break
                        }
                    }
        
                    # If there is a tie, add the current player to the Winners list
                    if (Tie) {
                        Winners:pushString(PlayerID)
                    }
                }
            }
        
            # Generate winner names
            let GetNames = function() {
                let Result = ""
                foreach(Index:number, PlayerID:string = Winners) {
                    let Entity = Players[PlayerID, table]["Entity", entity]
                    let Name = Entity:isValid() ? Entity:name() : "Player " + PlayerID
                    Result += Name
                    if (Index < Winners:count()) {
                        Result += ", "
                    }
                }
                return Result
            }
        
            # Message the result
            Players:keys():msgAll((Winners:count() > 1 ? "Split Pot: " : "Winner: ") + GetNames()[string] + 
            " with " + BestHand["Description", string])
            
            let PayOuts = table()
            
            # Reveal all winners hands
            foreach(_:number, PlayerID:string = Winners) {
                let Player = Players[PlayerID, table]
                revealHand(PlayerID)
                PayOuts:pushTable(
                    table(
                        "Seat" = Player["Seat", number], 
                        "MaxPot" = Player["MaxPot", number]
                    )
                )
            }
            payWinners(PayOuts)
            ResetBoard()
        break
        default,
        break
    }
    return NewState
}


# =================== Poker Deck Functions ================= #

# Function to create the Deck
function table deckCreate() {
    let Deck = table()
    
    # Lambda to create a card
    let Card_create = function(Rank:string, Suit:string) {
        let Card = table()
        Card["Rank"] = Rank
        Card["Suit"] = Suit
        Card["toString"] = function() {
            return Card["Rank", string] + " of " + Card["Suit", string]
        }
        return Card
    }
    Deck["Cards"] = table()
    
    # Initialize the deck
    Deck["initialize"] = function() {
        let Suits = array("Hearts", "Diamonds", "Clubs", "Spades")
        let Ranks = array("2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A")
        
        foreach(_:number, Suit:string = Suits) {
            foreach(_:number, Rank:string = Ranks) {
                let Card = Card_create(Rank, Suit)[table]
                Deck["Cards", table]:pushTable(Card)
            }
        }
    }
    
    # Shuffle the deck
    Deck["shuffle"] = function() {
        let Cards = Deck["Cards", table]
        let Count = Cards:count()
        for (I = Count, 1, -1) {
            let J = randint(1, I) # Random index between 0 and I
            # Swap Cards[I] and Cards[J]
            let Temp = Cards[I, table]
            Cards[I] = Cards[J, table]
            Cards[J] = Temp
        }
    }
    
    # Draw a card
    Deck["draw"] = function() {
        let Cards = Deck["Cards", table]
        if (Cards:count()) {
            let FirstCard = Cards[1, table] # Get the first card
            Deck["Cards", table]:shift()
            return FirstCard
        }
        return table() # Deck is empty
    }
    
    return Deck
}

# Add a player to the table
function void table:addPlayer(Entity:entity, Chips:number, Seat:number) {
    let SteamID = Entity:isValid() ? Entity:steamID() : "Debug "+Seat
    This[SteamID, table] = table(
        "Entity" = Entity,
        "Cards" = table(),
        "Chips" = Chips,
        "Seat" = Seat,
        "InPlay" = 0,
        "Action" = 0,
        "TotalBet" = 0,
        "CurrentBet" = 0,
        "MaxPot" = 0
    )
    let Name = Entity:isValid() ? Entity:name() : "Debug "+Seat
    foreach(_:string, Player:table = Players) {
        Player["Entity", entity]:msg(Name + " has joined the table.")
    }
    drawPlayer(Seat, Name, Chips)
}

function table:removePlayer(Entity:entity) {
    let Name = Entity:isValid() ? Entity:name() : "Player"
    let Seat = 0
    foreach(_:string, Player:table = Players) {
        Player["Entity", entity]:msg(Name + " has left the table.")
        if (Player["Entity", entity] == Entity) {
            Seat = Player["Seat", number]
        }
    }
    if (Seat) {
        This:removeTable(Entity:steamID())
        drawEmptySeat(Seat)
    }
    else {
        owner():msg("Cannot find " + Entity:name())
    }
}

function entity getSeatEntity(SeatNumber:number) {
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == SeatNumber) {
            return Player["Entity", entity]
        }
    }
    return _NO_ENTITY
}

function number getSeatNumber(Entity:entity) {
    foreach(_:string, Player:table = Players) {
        if (Player["Entity", entity] == Entity) {
            return Player["Seat", number]
        }
    }
    return 0
}

function number joinTable(Player:entity, SeatNumber:number) {
    if (Player == _NO_ENTITY && getSeatEntity(SeatNumber) == _NO_ENTITY) {
        Players:addPlayer(Player, BuyIn, SeatNumber) # For Debug Players
        return 1
    }
    if (getSeatEntity(SeatNumber) != _NO_ENTITY) {
        return 0
    }
    if(getSeatNumber(Player)) {
        Player:msg("You are already seated.")
        return 0
    }
    Players:addPlayer(Player, BuyIn, SeatNumber)
    return 1
}

function void start() {
    Players:keys():msgAll("Game starting soon...")
    InPlay = 1
}

function void showdown() {
    let Showdown = function() {}
    Showdown = function() {
        if(updateGameState() != "Showdown") {
            timer(3, function() { 
                Showdown() 
            }) 
        }
    }
    Showdown()
}


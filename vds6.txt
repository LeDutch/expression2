@name VDS6
@inputs [D1, D2, D3, HUD]:wirelink [MIN MAX]:entity
@persist [DoorRadius, Stranger]:number DoorArray:array
@persist [Users, Managers, Classes, Cindex, Config]:table


function entity string:findPlayer() {
    return This:sub(1, 5):upper() == "STEAM" ? findPlayerBySteamID(This) : findPlayerByName(This)
}

if (first() | dupefinished()) {
    DoorRadius = 30
}

if (first() || dupefinished() || ~D1 || ~D2 || ~D3) {
    DoorArray = array()
    if (D1:entity():isValid()) {DoorArray:pushWirelink(D1)}
    if (D2:entity():isValid()) {DoorArray:pushWirelink(D2)}
    if (D3:entity():isValid()) {DoorArray:pushWirelink(D3)}
}

if (~HUD) {reset()}

if (first() | dupefinished()) {
    entity():setSubMaterial(1, "lights/white")
    entity():setSubMaterial(3, "bull/gates/gate_aperture")
    entity():setColor(vec(255,255,0))
    findIncludeClass("player")
    fileLoad("vdsconfig.txt")

    Users = table(owner():steamID() = owner():name())
    Managers = table(owner():steamID() = owner():name())
    Classes = table()
    Config = table()
    Cindex = table(
        "THIEF" = array("Thief","CUSTOM_THIEF","Pickpocket Thief", "Parkour Thief", "Professional Thief"),
        "POLICE" = array("Police","CUSTOM_POLICE","Mayor","SWAT", "SWAT Medic", "SWAT Sniper", "Police Chief", "Police Officer", "Secret Service"),
        "MAFIA" = array("Mafia", "Mafia Member", "Mafia Leader"),
        "GANGSTER" = array("Gangster", "Gangster Leader"),
        "HOBO" = array("Hobo"),
        "CITIZEN" = array("Citizen", "CUSTOM_CITIZEN")
    )

    HUD:egpClear()
    HUD:egpDrawTopLeft(1)
    HUD:egpRoundedBox(2, vec2(56,110), vec2(375,80)), HUD:egpColor(2,20,20,20,200)
    HUD:egpRoundedBoxOutline(3,vec2(56,110),vec2(375,80)), HUD:egpColor(3,vec(20,20,20)), HUD:egpSize(3, 3)
    HUD:egpText(4, "VDS Alarm System", vec2(243.5, 110)), HUD:egpAlign(4, 1)
    HUD:egpRoundedBox(12, vec2(61,135), vec2(365,50)), HUD:egpSize(12, 35), HUD:egpAlign(12,1)

    timer("CONFIG", 3000)
}

if (first() | dupefinished()) {
    function void restore() {
            entity():setColor(vec(255,0,0))
            Config["Version", number] = 6.0
            Config["Default", number] = 0
            Config["AutoSave", number] = 0
            Config["1", table] = table()
            Config["2", table] = table()
            Config["3", table] = table()
            Config["TempUsers", table] = Users
            Config["TempManagers", table] = Managers
            Config["TempClasses", table] = Classes
            fileWrite("vdsconfig.txt", jsonEncode(Config))
            timer("Restart", 1000)
    }

    function void msg(Player:entity, String:string, NoHeader:number) {
        if (Player == owner()) {
            print((NoHeader ? "" : "{grey [}{orange VDS}{grey ]} ") + String)
        } else {
            Player:tauSendChatMsg((NoHeader ? "" : "{grey [}{orange VDS}{grey ]} ") + String)
        }
    }

    function void validate(Player:entity, Scope:number) {
        return (Scope && Managers:exists(Player:steamID())) || Player == owner() 
    }

    function entity lookup(Player:entity, Target:string, Scope:number) {
        if (validate(Player, Scope)) {
            let TargetEntity = Target:findPlayer()
            if (!TargetEntity:isValid()) {
                msg(Player, "{! [ ! ]}: No {yellow Player} found named {yellow " + Target:upper() + "}", 0)
            } else {
                return TargetEntity
            }
        }
        return noentity()
    }
}

if (first() | dupefinished()) {
    function void entity:cmd(CMD:string, ARGS:array) {
        switch (CMD) {
            case "ADD",
            case "A",
                let Target = lookup(This, ARGS[1, string], 1)
                if (Target != noentity()) {
                    if (!Users:exists(Target:steamID())) {
                        msg(This, "{!green [ - ]}: {yellow You} added {yellow " + Target:name():upper() + "} to {purple Users}", 0)
                        Users[Target:steamID(), string] = Target:name()
                        Config["TempUsers", table] = Users
                        fileWrite("vdsconfig.txt", jsonEncode(Config))
                    } else {
                        msg(This, "{! [ ! ]}: {yellow " + Target:name():upper() + "} is already added to {purple Users}", 0)
                    }
                }
            break

            case "ADDMANAGER",
            case "AM",
                let Target = lookup(This, ARGS[1, string], 0)
                if (Target != noentity()) {
                    if (!Managers:exists(Target:steamID())) {
                        msg(This, "{!green [ - ]}: {yellow You} added {yellow " + Target:name():upper() + "} to {purple Managers}", 0)
                        Managers[Target:steamID(), string] = Target:name()
                        Config["TempManagers", table] = Managers
                        fileWrite("vdsconfig.txt", jsonEncode(Config))
                    } else {
                        msg(This, "{! [ ! ]}: {yellow " + Target:name():upper() + "} is already added to {purple Managers}", 0)
                    }
                }
            break

            case "ADDCLASS",
            case "AC",
                if (validate(This, 1)) {
                    let ClassName = ARGS[1, string]:upper()
                    if(Cindex:exists(ClassName)){
                        let Class = Cindex[ClassName,array]
                        if (invert(Classes):exists(ClassName)) {
                            msg(This, "{! [ ! ]}: {cyan " + ClassName + "} are already added to {purple Classes}", 0)
                        } else {
                            if (ClassName == "POLICE") {entity():setColor(vec(0,255,255))}
                            for (I = 1, Class:count()) {
                                Classes[Class[I, string], string] = ClassName
                            }
                            msg(This, "{!green [ - ]}: {yellow You} added {cyan " + ClassName + "} to {purple Classes}", 0)
                        }
                    } else {
                        msg(This, "{! [ ! ]}: No {cyan Class} found named {cyan " + ClassName + "}", 0)
                    }
                }
            break

            case "DELETE",
            case "DEL",
            case "D",
                let Target = lookup(This, ARGS[1, string], 1)
                if (Target != noentity()) {
                    if (Users:exists(Target:steamID())) {
                        msg(This, "{!green [ - ]}: {yellow You} removed {yellow " + Target:name():upper() + "} from {purple Users}", 0)
                        Users:unset(Target:steamID())
                        Config["TempUsers", table] = Users
                        fileWrite("vdsconfig.txt", jsonEncode(Config))
                    } else {
                        msg(This, "{! [ ! ]}: {yellow " + Target:name():upper() + "} isn't added to {purple Users}", 0)
                    }
                }
            break

            case "DELETEMANAGER",
            case "DELMANAGER",
            case "DM",
                let Target = lookup(This, ARGS[1, string], 0)
                if (Target != noentity()) {
                    if (Managers:exists(Target:steamID())) {
                        msg(This, "{!green [ - ]}: {yellow You} removed {yellow " + Target:name():upper() + "} from {purple Managers}", 0)
                        Managers:unset(Target:steamID())
                        Config["TempManagers", table] = Managers
                        fileWrite("vdsconfig.txt", jsonEncode(Config))
                    } else {
                        msg(This, "{! [ ! ]}: {yellow " + Target:name():upper() + "} isn't added to {purple Managers}"  , 0)
                    }
                }
            break

            case "DELETECLASS",
            case "DELCLASS",
            case "DC",
                if (validate(This, 1)) {
                    hideChat(1)
                    let ClassName = ARGS[1,string]:upper()
                    if(Cindex:exists(ClassName)){
                        let Class = Cindex[ClassName,array]
                        if (!invert(Classes):exists(ClassName)) {
                            msg(This, "{! [ ! ]}: {cyan " + ClassName + "} aren't added to {purple Classes}", 0)
                        } else {
                            if (ClassName == "POLICE") {entity():setColor(vec(0,255,0))}
                            for (I = 1, Class:count()) {
                                Classes:unset(Class[I, string])
                            }
                            msg(This, "{!green [ - ]}: {yellow You} removed {cyan " + ClassName + "} from {purple Classes}", 0)
                        }
                    }else{
                        msg(This, "{! [ ! ]}: No {cyan Class} found named {cyan " + ClassName + "}", 0)
                    }
                }
            break

            case "USERS",
            case "U",
                if (validate(This, 1)) {
                    msg(This, "Viewing {purple Users}:", 0)
                    let PlayerID = Users:keys()
                    for (I = 1, PlayerID:count()) {
                        let PlayerName = Users[PlayerID[I, string], string]
                        msg(This, "{red " + I:toString() + ".} {yellow " + PlayerName + "} (" + PlayerID[I, string] + ")", 1)
                    }
                }
            break

            case "MANAGERS",
            case "M",
                if (validate(This, 1)) {
                    msg(This, "Viewing {purple Managers}:", 0)
                    let PlayerID = Managers:keys()
                    for (I = 1, PlayerID:count()) {
                        let PlayerName = Managers[PlayerID[I, string], string]
                        msg(This, "{red " + I:toString() + ".} {yellow " + PlayerName + "} (" + PlayerID[I, string] + ")", 1)
                    }
                }
            break

            case "CLASSES",
            case "C",
                if (validate(This, 1)) {
                    msg(This, "Viewing {cyan Classes}:", 0)
                    let ClassNames = Classes:keys()
                    for(I = 1, ClassNames:count()) {
                        msg(This, "{red " + I:toString() + ".} {yellow " + ClassNames[I, string] + "}", 1)
                    }
                    hideChat(1)
                }
            break

            case "SET",
                if (validate(This, 0)) {
                    let Choice = ARGS[1, string]:toNumber()
                    if(Choice >= 0 & Choice <= 3) {
                        Config["Default", number] = Choice
                        fileWrite("vdsconfig.txt", jsonEncode(Config))
                        msg(This, "{!green [ - ]}: Default preset set to preset {yellow " + ARGS[1, string]:toNumber() + "}", 0)
                    } else {
                        msg(This, "{! [ ! ]}: {yellow " + Choice + "} isn't a valid preset {yellow [0-3]}", 0)
                    }
                }
            break

            case "SAVE",
                if (validate(This, 0)) {
                    let Choice = (ARGS[1, string]:toNumber())
                    if(Choice >= 1 & Choice <= 3) {
                        Config[Choice, table] = Users:clone()
                        msg(This, "{!green [ - ]}: Overriding custom preset {yellow " + ARGS[1, string]:toNumber() + "}", 0)
                        fileWrite("vdsconfig.txt", jsonEncode(Config))
                    } elseif (Choice == 0) {
                        msg(This, "{! [ ! ]}: You cannot override the default preset {yellow [1-3]}", 0)
                    } else {
                        msg(This, "{! [ ! ]}: {yellow " + Choice + "} isn't a valid custom preset {yellow [1-3]}", 0)
                    }
                }
            break

            case "LOAD",
                if (validate(This, 0)) {
                    let Choice = (ARGS[1, string]:toNumber())
                    if(Choice >= 1 & Choice <= 3) {
                        if (Choice != 0) {
                            Users = Config[Choice,table]
                        } else {
                            Users = table(owner():steamID() = owner():name())
                        }
                        msg(This, "{!green [ - ]}: Overriding Users with preset {yellow " + ARGS[1, string]:toNumber() + "}", 0)
                    } else {
                        msg(This, "{! [ ! ]}: {yellow " + Choice + "} isn't a valid preset {yellow [0-3]}", 0)
                    }
                }
            break

            case "VIEW",
                if (validate(This, 0)) {
                    let Choice = (ARGS[1, string]:toNumber())
                    if(Choice >= 1 & Choice <= 3) {
                        msg(This, "Viewing {purple Custom Preset " + Choice + "}:", 0)
                        let PlayerSteamID = Config[Choice,table]:keys()
                        for (I = 1, PlayerSteamID:count(    )) {
                            let PlayerName = Users[PlayerSteamID[I, string], string]
                            msg(This, "{red " + I:toString() + ".} {yellow " + PlayerName + "} (" + PlayerSteamID[I, string] + ")", 1)
                        }
                    } else {
                        msg(This, "{! [ ! ]}: {yellow " + Choice + "} isn't a valid custom preset {yellow [1-3]}", 0)
                    }
                }
            break

            case "AUTOSAVE",
                if (validate(This, 0)) {
                    let BOOLEAN = Config["AutoSave", number]
                    if(fileCanWrite()) {
                        if (BOOLEAN == 1) {
                            Config["AutoSave", number] = 0
                            fileWrite("vdsconfig.txt", jsonEncode(Config))
                            msg(This, "{!green [ - ]}: Autosave was {red Disabled}", 0)
                        } else {
                            Config["AutoSave", number] = 1
                            fileWrite("vdsconfig.txt", jsonEncode(Config))
                            msg(This, "{!green [ - ]}: Autosave was {green Enabled}", 0)
                        }
                    } else {
                        msg(This, "{! [ ! ]}: Failed saving change to config", 0)
                    }
                }
            break

            default,
                hideChat(0)
        }
    }
}

event chat(Player:entity, Text:string, _:number) {
    if (validate(Player, 1)) {
        if (Text:sub(1, 1) == "!") {
            let ARGS = Text:explode(" ")
            let CMD = ARGS[1, string]:upper()
            ARGS:remove(1)
            Player:cmd(CMD:sub(2), ARGS)
            hideChat(1)
        }
    }
}

event fileLoaded(Name:string, Content:string) {
    if (Name == "vdsconfig.txt") {
        Config = jsonDecode(Content)
    }
}

CLK = clkName()
if (CLK) {
    switch (CLK) {
        case "CONFIG",
            if ((Config["Version", number] != 0) && (Config["Version", number] >= 6.0)) {
                if (Config["AutoSave", number] != 1) {
                    if (Config["Default", number] >= 1 && Config["Default", number] <= 3) {
                        Users = Config[Config["Default", number],table]
                    } else {
                        Users = table(owner():steamID() = owner():name())
                        Managers = table(owner():steamID() = owner():name())
                        Config["Default", number] = 0
                    }
                } else {
                    Users = Config["TempUsers", table]
                    Managers = Config["TempManagers", table]
                    Classes = Config["TempClasses", table]
                }
                entity():setColor(vec(0,255,0))
                fileWrite("vdsconfig.txt", jsonEncode(Config))
                timer("checkUser", 250)
            } else {
                restore()
            }

        break

        case "checkUser",
            timer("checkUser", 400)
            if (findCanQuery()){
                Stranger = 0

                foreach (K:number, V:wirelink = DoorArray) {
                    if (!V:entity():isValid()) { print(K), continue }
                    let KEY = "F" + K

                    if (!V["FadeActive", number]) {
                        findInSphere(V:entity():pos(), DoorRadius)
                        let DoorFound = findToArray()
                        if (DoorFound:count() != 0){
                            foreach (_:number, PLY:entity = DoorFound) {
                                if (!PLY:isAlive()) {continue}
                                if (Users:exists(PLY:steamID()) || Classes:exists(PLY:team():teamName())) {
                                    V["Fade", number] = 1
                                    timer(KEY, 4000)
                                } else {
                                    Stranger = 1
                                }
                            }
                        }
                    }
                }

                if (MIN:isValid() && MAX:isValid()) {
                    findInBox(MIN:pos(), MAX:pos())
                    let BoxFound = findToArray()
                    if (BoxFound:count() != 0){
                        foreach(_:number, PLY:entity = BoxFound) {
                            if (!PLY:isAlive()) { continue }
                            if (!Users:exists(PLY:steamID()) && !Classes:exists(PLY:team():teamName())) {
                                Stranger = 1
                            }
                        }
                    }
                }
            }
        break

        case "F1", DoorArray[1, wirelink]["Fade", number] = 0, break
        case "F2", DoorArray[2, wirelink]["Fade", number] = 0, break
        case "F3", DoorArray[3, wirelink]["Fade", number] = 0, break
        case "Restart", reset()
    }
}

HUD:egpColor(12, (Stranger != 0) ? vec(255, 0, 0) : vec(0, 255, 0))

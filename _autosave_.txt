@name Tomato Poker Logic
@persist [Players CommunityCards Deck AllIn]:table
@persist [GameState CoinSeat BuyIn InPlay ActionSeat Pot CurrentBet MinBet]:number
@persist [SeatsInPlay]:array

#include "lib/tomato/1.1/tomato_ui"
#include "lib/tomato/1.1/tomato_core"
#include "tomato/poker/graphics"

# Function to create the Deck
function table deckCreate() {
    let Deck = table()
    
    # Lambda to create a card
    let Card_create = function(Rank:string, Suit:string) {
        let Card = table()
        Card["Rank"] = Rank
        Card["Suit"] = Suit
        Card["toString"] = function() {
            return Card["Rank", string] + " of " + Card["Suit", string]
        }
        return Card
    }
    Deck["Cards"] = table()
    
    # Initialize the deck
    Deck["initialize"] = function() {
        let Suits = array("Hearts", "Diamonds", "Clubs", "Spades")
        let Ranks = array("2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A")
        
        foreach(_:number, Suit:string = Suits) {
            foreach(_:number, Rank:string = Ranks) {
                let Card = Card_create(Rank, Suit)[table]
                Deck["Cards", table]:pushTable(Card)
            }
        }
    }
    
    # Shuffle the deck
    Deck["shuffle"] = function() {
        let Cards = Deck["Cards", table]
        let Count = Cards:count()
        for (I = Count, 1, -1) {
            let J = randint(1, I) # Random index between 0 and I
            # Swap Cards[I] and Cards[J]
            let Temp = Cards[I, table]
            Cards[I] = Cards[J, table]
            Cards[J] = Temp
        }
    }
    
    # Draw a card
    Deck["draw"] = function() {
        let Cards = Deck["Cards", table]
        if (Cards:count()) {
            let FirstCard = Cards[1, table] # Get the first card
            Deck["Cards", table]:shift()
            return FirstCard
        }
        return table() # Deck is empty
    }
    
    return Deck
}

if (first() || dupefinished()) {
    Players = table()
    CommunityCards = table()
    AllIn = table()
    Deck = deckCreate()
    SeatsInPlay = array()
    GameState = 0
    CoinSeat = 0
    ActionSeat = 0
    CurrentBet = 0
    Pot = 0
    InPlay = 0
    BuyIn = 100000
    MinBet = BuyIn / 100
}

# =================== Poker Helper Functions =============== #

function array sortAscending(Array:array) {
    for (I = 1, Array:count() - 1) {
        for (J = I + 1, Array:count()) {
            let A = Array[J, number]
            let B = Array[I, number]
            if (A < B) {
                let Temp = Array[I, number]
                Array[I] = Array[J, number]
                Array[J] = Temp
            }
        }
    }
    return Array
}

function number indexOf(Value:string, Array:array) {
    for (Index = 1, Array:count()) {
        if (Array[Index, string] == Value) {
            return Index
        }
    }
    return 0
}

function void broadcast(Text:string) {
    foreach(_:string, Player:table = Players) {
        let Entity = Player["Entity", entity]
        if (Entity:isValid()) {
            Entity:msg(Text)
        }
    }
}

function array seatsInPlay() {
    let Array = array()
    foreach(_:string, Player:table = Players) {
        if(Player["InPlay", number]) {
            let Seat = Player["Seat", number]
            Array:pushNumber(Seat)
        }
    }
    return Array
}

function array seatsWithAction() {
    let Array = array()
    foreach(_:string, Player:table = Players) {
        if(Player["InPlay", number] && Player["Chips", number] > 0) {
            let Seat = Player["Seat", number]
            Array:pushNumber(Seat)
        }
    }
    return Array
}

function table playerFromSeat(Seat:number) {
    foreach(_:string, Player:table = Players) {
        if(Player["Seat", number] == Seat) {
            return Player
        }
    }
    print("Player from seat error")
    return table()
}



# =================== Poker Logic Functions ================ #

function void assignCoin() {
    let NextCoinSeat = function(Sorted:array, CoinSeat:number) {
        return Sorted[(Sorted:indexOf(CoinSeat) % Sorted:count()) + 1, number]
    }
    if (!CoinSeat) {
        CoinSeat = SeatsInPlay[randint(1, SeatsInPlay:count()), number]
        drawDealerCoin(CoinSeat)
        broadcast("Dealercoin assigned randomly.")
    }
    else {
        CoinSeat = NextCoinSeat(SeatsInPlay, CoinSeat)[number]
        drawDealerCoin(CoinSeat)
    }
    return
}

function void revealHand(PlayerID:string) {
    let HandtoString = function(Cards:table) {
        let CardsString = ""
        foreach (Index:number, Card:table = Cards) {
            CardsString += Card["toString", function]()[string]
            if (Index < Cards:count()) {
                CardsString += ", "
            }
        }
        return CardsString
    }
    let RevealedPlayer = Players[PlayerID, table]
    let Seat = RevealedPlayer["Seat", number]
    let Cards = RevealedPlayer["Cards", table]
    let Hand = HandtoString(Cards)[string]
    let Entity = RevealedPlayer["Entity", entity]
    let Name = Entity:isValid() ? Entity:name() : "Player " + PlayerID
    
    deleteShowHand(Seat)
    
    let ShowCard = function(Name:string) {
        if (!Elements:exists(Name)) { return }
        let Obj = EGP:egpobject(Elements:get(Name))
        if (!Obj) { return }
        Obj["a", number] = 255
    }
    
    timer(1, function() {
        suit_rank("Card1" + Seat, Cards[1, table])
        suit_rank("Card2" + Seat, Cards[2, table])
    })
    
    ShowCard("Card1" + Seat)
    ShowCard("Card1" + Seat + "_border")
    ShowCard("Card2" + Seat)
    ShowCard("Card2" + Seat + "_border")
    
    revealCardAnim(Seat)
    broadcast(Name + " revealed " + Hand)
}

# =================== Poker Core Functions ================= #

function table evaluateHand(Player:table) {
    if (!Player["InPlay", number]) {
        return table("Points"=0, "Description"="folded.", "HighCards"=array())
    }
    let PlayerCards = Player["Cards", table]
    let OrderedRanks = array("2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A")
    
    # Helper function to combine PlayerCards hand and community cards
    let Concat = function(Table1:table, Table2:table) {
        let Primary = Table1:clone()
        foreach(_:number, Value:table = Table2) {
            Primary:pushTable(Value)
        }
        return Primary
    }
    
    let Cards = Concat(PlayerCards, CommunityCards)[table]
    let Suits = table()
    let Ranks = table()

    # Populate the suits and ranks frequency tables
    foreach(_:number, Card:table = Cards) {
        let Suit = Card["Suit", string]
        let Rank = Card["Rank", string]
        
        Suits[Suit] = Suits[Suit, number] + 1
        Ranks[Rank] = Ranks[Rank, number] + 1
    }
    
    
    # isStraight helper function
    let IsStraight = function(Ranks:table) {
        let Indices = array()
        foreach(_:number, Rank:string = OrderedRanks) {
            if (Ranks[Rank, number]) {
                Indices:pushNumber(OrderedRanks:indexOf(Rank))
            }
        }
        
        for (I = 1, Indices:count() - 4) {
            if (Indices[I + 4, number] - Indices[I, number] == 4) {
                return OrderedRanks[Indices[I + 4, number], string]
            }
        }
        return ""
    }
    
    # Sort for Strings - Helper function
    let SortDescending = function(Array:array) {
        let RankAdjust = function(String:string) {
            let Number = String:toNumber()
            switch (String) {
                case "A",
                    Number = 13
                break
                case "K",
                    Number = 12
                break
                case "J",
                    Number = 11
                break
                default,
                break
            }
            return Number
        }
        for (I = 1, Array:count() - 1) {
            for (J = I + 1, Array:count()) {
                let A = RankAdjust(Array[J, string])[number]
                let B = RankAdjust(Array[I, string])[number]
                if (A > B) {
                    let Temp = Array[I, string]
                    Array[I] = Array[J, string]
                    Array[J] = Temp
                }
            }
        }
        return Array
    }

    # Check for flush and assign the highest rank in the flush
    let FlushRank = ""
    let FlushSuit = ""
    foreach(Suit:string, Count:number = Suits) {
        if (Count >= 5) {
            # Collect cards of the flush suit
            let FlushCards = array()
            FlushSuit = Suit
            foreach(_:number, Card:table = Cards) {
                if (Card["Suit", string] == Suit) {
                    FlushCards:pushString(Card["Rank", string])
                }
            }
    
            # Sort FlushCards to find the highest rank
            FlushCards = SortDescending(FlushCards)[array]
            FlushRank = FlushCards[1, string] # Assign the highest rank
            break
        }
    }

    # Check for straight flush and royal flush
    if (FlushSuit != "") {
        let FlushRanks = table()
        foreach(_:number, Card:table = Cards) {
            if (Card["Suit", string] == FlushSuit) {
                FlushRanks[Card["Rank", string]] = 1
            }
        }
        let HighestCardInStraight = IsStraight(FlushRanks)[string]
        if (HighestCardInStraight != "") {
            if (HighestCardInStraight == "A") {
                return table("Points"=10, "Description"="Royal Flush", "HighCards"=table("A"))
            }
            return table("Points"=9, "Description"="Straight Flush", "HighCards"=table(HighestCardInStraight))
        }
    }

    # Other hands: Four of a kind, full house, etc.
    let FourKind = ""
    let ThreeKind = ""
    let PairRanks = array() # Array to track all pairs
    let Kickers = array()
    let HighestStraight = IsStraight(Ranks)[string]
    
    # Evaluate Ranks
    foreach(Rank:string, Count:number = Ranks) {
        if (Count == 4) {
            FourKind = Rank
        } elseif (Count == 3) {
            ThreeKind = Rank
        } elseif (Count == 2) {
            PairRanks:pushString(Rank) # Track all pairs
        }
        else {
            Kickers:pushString(Rank)
        }
    }
    
    # Sort PairRanks in descending order for tie-breaking
    PairRanks = SortDescending(PairRanks)[array]
    let SortedKickers = SortDescending(Kickers)[array]
    
    if (FourKind != "") {
        return table("Points"=8, "Description"="Four of a Kind", "HighCards"=array(FourKind):add(SortedKickers))
    }
    if (ThreeKind != "" && PairRanks:count() > 0) {
        return table("Points"=7, "Description"="Full House", "HighCards"=array(ThreeKind, PairRanks[1, string]))
    }
    if (FlushRank != "") {
        return table("Points"=6, "Description"="Flush", "HighCards"=array(FlushRank))
    }
    if (HighestStraight != "") {
        return table("Points"=5, "Description"="Straight", "HighCards"=array(HighestStraight))
    }
    if (ThreeKind != "") {
        return table("Points"=4, "Description"="Three of a Kind", "HighCards"=array(ThreeKind):add(SortedKickers))
    }
    if (PairRanks:count() >= 2) {
        let HighPair = PairRanks[1, string]
        return table("Points"=3, "Description"="Two Pair", "HighCards"=array(HighPair):add(SortedKickers))
    }
    if (PairRanks:count() == 1) {
        let HighPair = PairRanks[1, string]
        return table("Points"=2, "Description"="One Pair", "HighCards"=array(HighPair):add(SortedKickers))
    }

    # If other checks fail, detect the high card
    for (Index = OrderedRanks:count(), 1, -1) {
        let Rank = OrderedRanks[Index, string]
        if (Ranks[Rank, number]) {
            return table("Points"=1, "Description"="High Card", "HighCards"=array(Rank):add(SortedKickers))
        }
    }

    return table("Points"=0, "Description"="No Hand", "HighCards"=array())
}

function array findWinners(Eligible:array, Hands:table) {
    let OrderedRanks = array("2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A")
    let BestHand = table("Points"=0, "HighCards"=array())
    let Winners = array()
    foreach(_:number, PlayerID:string = Eligible) {
        let EvaluatedHand = Hands[PlayerID, table]
        if (!EvaluatedHand) {
            let Player = Players[PlayerID, table]
            EvaluatedHand = evaluateHand(Player)
            Hands[PlayerID, table] = EvaluatedHand
        }
        if (EvaluatedHand["Points", number] > BestHand["Points", number]) {
            BestHand = EvaluatedHand
            Winners = array(PlayerID)
        }
        elseif (EvaluatedHand["Points", number] == BestHand["Points", number]) {
            let BestCards = BestHand["HighCards", array]
            let CurrentBestCards = EvaluatedHand["HighCards", array]
            let Tie = 1
            foreach(Index:number, HighCard:string = BestCards) {
                let BestRank = indexOf(HighCard, OrderedRanks)
                let CurrentRank = indexOf(CurrentBestCards[Index, string], OrderedRanks)
                if (CurrentRank > BestRank) {
                    BestHand = EvaluatedHand
                    Winners = array(PlayerID)
                    Tie = 0
                    break
                } elseif (CurrentRank < BestRank) {
                    Tie = 0
                    break
                }
            }
            if (Tie) {
                Winners:pushString(PlayerID)
            }
        }
    }
    return Winners
}

function string bet(Player:table) {
    let Seat = Player["Seat", number]
    let Entity = Player["Entity", entity]
    let Chips = Player["Chips", number]
    let PlayerBet = Player["CurrentBet", number]
    let Amount = max(0, CurrentBet - PlayerBet)
    let AmountToPut = min(Amount, Chips)
    Pot += AmountToPut
    Player["Chips", number] = Chips - AmountToPut
    Player["CurrentBet", number] = PlayerBet + AmountToPut
    Player["TotalBet", number] = Player["TotalBet", number] + AmountToPut
    if (Player["Chips", number] == 0) {
        AllIn[Player["ID", string]] = Player["TotalBet", number]
    }
    Player["Action", number] = 1

    let IsAllIn = Player["Chips", number] == 0
    drawCurrentBet(Seat, Player["CurrentBet", number], IsAllIn, BuyIn)
    updateChips(Seat, Player["Chips", number])
    updatePot(Pot)
    
    return Entity:isValid() ? Entity:name() : "Player " + toString(Seat)
}

function void foldHand(Seat:number) {
    if (Seat < 2 | Seat > 8) { return }
    deleteButtons(Seat)
    let Name = "Player " + Seat
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == Seat) {
            Player["InPlay", number] = 0
            let Entity = Player["Entity", entity]
            if (Entity != _NO_ENTITY) {
                Name = Entity:name()
            }
        }
    }
    
    broadcast(Name + " has folded.")
    SeatsInPlay = sortAscending(seatsInPlay())
    for (I=1, 2) {
        let Card = "Card" + I + Seat
        let Border = Card + "_border"
        if (Elements:exists(Card)) {
            fadeOut(Card, 0.5)
        }
        if (Elements:exists(Border)) {
            fadeOut(Border, 0.5)
        }
    }
}

function void checkOrCall(Seat:number) {
    if (Seat < 2 | Seat > 8) { return }
    deleteButtons(Seat)
    let Name = "Player " + Seat
    let Description = "checked."
    let NeedsCall = 0
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == Seat) {
            NeedsCall = max(0, CurrentBet - Player["CurrentBet", number])
            if (NeedsCall > 0) {
                Description = "called $" + CurrentBet
            }
            Name = bet(Player)
            if(Player["Chips", number] < CurrentBet) {
                Description = "went all in (" + Player["Chips", number]+")."
            }
        }
    }
    broadcast(Name + " has " + Description)
    if (NeedsCall > 0) {
        soundPlay(2,0.3,"pcasino/chip/chip_2.wav")
    }
}

function void raise(Seat:number, Amount:number) {
    if (Seat < 2 | Seat > 8) { return }
    deleteButtons(Seat)
    let Description = "raised $" + Amount
    let Name = "Player " + Seat
    let DidRaise = 0
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == Seat) {
            if (Player["Chips", number] < MinBet) {
                let AllInBet = Player["CurrentBet", number] + Player["Chips", number]
                if (AllInBet > CurrentBet) {
                    CurrentBet = AllInBet
                    DidRaise = 1
                }
                Name = bet(Player)
                Description = "went all in (" + Player["CurrentBet", number] + ")."
            }
            else {
                if (Amount <= CurrentBet) {
                    checkOrCall(Seat)
                    return
                }
                CurrentBet = Amount
                DidRaise = 1
                Name = bet(Player)
                if(Player["Chips", number] < CurrentBet) {
                    Description = "went all in (" + Player["CurrentBet", number]+")."
                }
            }
        }
        else {
            if (DidRaise) {
                Player["Action", number] = 0
            }
        }
    }
    broadcast(Name + " has " + Description)
    soundPlay(2,0.3,"pcasino/chip/chip_1.wav")
}

function void blind(Seat:number, Amount:number) {
    CurrentBet = Amount
    let Name = "Player " + Seat
    let Blind = Amount == MinBet ? "big" : "small"
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == Seat) {
            Name = bet(Player)
            Player["Action", number] = 0
        }
    }
    broadcast(Name + " has paid the " + Blind + " blind.")
    soundPlay(2,0.3,"pcasino/chip/chip_2.wav")
}

function payWinners(Winners:table) {
    # Calculate total side pots and remaining pot
    let SidePots = 0
    let TotalPot = Pot

    # Helper function to find and update player information
    let UpdatePlayerChips = function(Seat:number, Payout:number) {
        foreach(_:string, Player:table = Players) {
            if (Player["Seat", number] == Seat) {
                let Entity = Player["Entity", entity]
                Player["Chips", number] = Player["Chips", number] + Payout
                updateChips(Seat, Player["Chips", number])
                return Entity:isValid() ? Entity:name() : "Player " + Seat
            }
        }
        return "Player " + Seat # Default to generic name
    }

    if (Winners:count() > 1) {
        foreach(_:string, Winner:table = Winners) {
            let MaxPot = Winner["MaxPot", number]
            if (MaxPot) {
                SidePots++
                TotalPot -= MaxPot
            }
        }
    
        # Distribute winnings
        foreach(_:string, Winner:table = Winners) {
            let Seat = Winner["Seat", number]
            let MaxPot = Winner["MaxPot", number]
            let Payout = MaxPot ? MaxPot : floor(TotalPot / (Winners:count() - SidePots))
    
            # Update chips and get player name
            let Name = UpdatePlayerChips(Seat, Payout)[string]
    
            # Announce the winner
            broadcast(Name + " has won " + abbreviateNum(Payout))
        }
    }
    else {
        let Seat = Winners[1, table]["Seat", number]
        let Payout = TotalPot
    
        # Update chips and get player name
        let Name = UpdatePlayerChips(Seat, Payout)[string]
    
        # Announce the winner
        broadcast(Name + " has won " + abbreviateNum(Payout))
    }

    # Reset the pot
    Pot = 0
    updatePot(Pot)
}

function void paySidePots() {
    let Bets = table()
    let Levels = array()
    let Hands = table()
    let TotalPaid = 0

    foreach(PlayerID:string, Player:table = Players) {
        let Bet = Player["TotalBet", number]
        Bets[PlayerID] = Bet
        Levels:pushNumber(Bet)
        if (Player["InPlay", number]) {
            Hands[PlayerID] = evaluateHand(Player)
        }
    }

    if (!Levels:count()) {
        Pot = 0
        updatePot(Pot)
        return
    }

    Levels = sortAscending(Levels)
    let Unique = array()
    let Last = -1
    foreach(_:number, Level:number = Levels) {
        if (Level > Last) {
            Unique:pushNumber(Level)
            Last = Level
        }
    }

    let UpdatePlayerChips = function(Seat:number, Payout:number) {
        foreach(_:string, Player:table = Players) {
            if (Player["Seat", number] == Seat) {
                Player["Chips", number] = Player["Chips", number] + Payout
                updateChips(Seat, Player["Chips", number])
                return
            }
        }
        return
    }

    let Prev = 0
    let TotalWins = table()
    let WinnerList = array()
    foreach(_:number, Level:number = Unique) {
        let CountAll = 0
        let Eligible = array()
        foreach(PlayerID:string, Bet:number = Bets) {
            if (Bet >= Level) {
                CountAll++
            }
            if (Bet >= Level && Players[PlayerID, table]["InPlay", number]) {
                Eligible:pushString(PlayerID)
            }
        }
        let PotAmount = (Level - Prev) * CountAll
        if (PotAmount > 0 && Eligible:count()) {
            let Winners = findWinners(Eligible, Hands)
            let Share = floor(PotAmount / Winners:count())
            foreach(_:number, WinnerID:string = Winners) {
                let Seat = Players[WinnerID, table]["Seat", number]
                UpdatePlayerChips(Seat, Share)
                TotalPaid += Share
                if (!TotalWins[WinnerID, number]) {
                    TotalWins[WinnerID, number] = 0
                    WinnerList:pushString(WinnerID)
                }
                TotalWins[WinnerID, number] = TotalWins[WinnerID, number] + Share
            }
        }
        Prev = Level
    }

    if (WinnerList:count() == 0 && Pot > 0) {
        let Eligible = array()
        foreach(PlayerID:string, Player:table = Players) {
            if (Player["InPlay", number]) {
                Eligible:pushString(PlayerID)
                Hands[PlayerID] = evaluateHand(Player)
            }
        }
        if (Eligible:count()) {
            let Winners = findWinners(Eligible, Hands)
            let Share = floor(Pot / Winners:count())
            foreach(_:number, WinnerID:string = Winners) {
                let Seat = Players[WinnerID, table]["Seat", number]
                UpdatePlayerChips(Seat, Share)
                TotalPaid += Share
                if (!TotalWins[WinnerID, number]) {
                    TotalWins[WinnerID, number] = 0
                    WinnerList:pushString(WinnerID)
                }
                TotalWins[WinnerID, number] = TotalWins[WinnerID, number] + Share
            }
        }
    }

    if (WinnerList:count() == 1) {
        let WinnerID = WinnerList[1, string]
        let Seat = Players[WinnerID, table]["Seat", number]
        let Entity = Players[WinnerID, table]["Entity", entity]
        let Name = Entity:isValid() ? Entity:name() : "Player " + Seat
        let HandDesc = Hands[WinnerID, table]["Description", string]
        if (HandDesc == "") { HandDesc = "a hand" }
        broadcast(Name + " has won " + abbreviateNum(TotalWins[WinnerID, number]) + " with " + HandDesc)
        revealHand(WinnerID)
    }
    else {
        let I = 0
        foreach(_:number, WinnerID:string = WinnerList) {
            let Seat = Players[WinnerID, table]["Seat", number]
            let Entity = Players[WinnerID, table]["Entity", entity]
            let Name = Entity:isValid() ? Entity:name() : "Player " + Seat
            let HandDesc = Hands[WinnerID, table]["Description", string]
            if (HandDesc == "") { HandDesc = "a hand" }
            broadcast(Name + " has won " + abbreviateNum(TotalWins[WinnerID, number]) + " with " + HandDesc)
            I++
            timer(I, function() {
                revealHand(WinnerID)
            })
        }
    }

    Pot = 0
    updatePot(Pot)
}

function table:removePlayer(Seat:number) {
    let GetEntity = function() {
        foreach(_:string, Player:table = This) {
            if (Player["Seat", number] == Seat) {
                return Player["Entity", entity]
            }
        }
        return _NO_ENTITY
    }
    let Entity = GetEntity()[entity]
    foreach(Steam:string, Player:table = This) {
        if (Entity:isValid()) {
            Player["Entity", entity]:msg(Entity:name() + " has left the table.")
        }
        else {
            Player["Entity", entity]:msg("Player " + Seat + " has left the table.")
        }
        if (Player["Seat", number] == Seat) {
            This:removeTable(Steam)
            drawEmptySeat(Seat)
        }
    }
}

function void processLeavingPlayers() {
    let Seats = array()
    let Entities = array()
    let Balances = array()
    foreach(_:string, Player:table = Players) {
        if (Player["Leaving", number]) {
            Seats:pushNumber(Player["Seat", number])
            Entities:pushEntity(Player["Entity", entity])
            Balances:pushNumber(Player["Chips", number])
        }
    }
    for (I=1, Seats:count()) {
        let Seat = Seats[I, number]
        let Entity = Entities[I, entity]
        let Chips = Balances[I, number]
        if (Entity:isValid()) {
            moneyGive(Entity, Chips)
        }
        #deletePlayerCards(Seat)
        deleteButtons(Seat)
        drawCurrentBet(Seat, 0, 0, BuyIn)
        drawEmptySeat(Seat)
        Players:removePlayer(Seat)
    }
}

function number isBot(Player:table) {
    let Entity = Player["Entity", entity]
    return !Entity:isValid()
}

function void botAct(Seat:number) {
    let Player = playerFromSeat(Seat)
    if (!Player["InPlay", number]) { return }
    if (Player["Chips", number] <= 0) { return }
    let Roll = randint(1, 3)
    if (Roll == 1) {
        checkOrCall(Seat)
    }
    elseif (Roll == 2) {
        foldHand(Seat)
    }
    else {
        let Target = max(CurrentBet + MinBet, MinBet * 2)
        raise(Seat, Target)
    }
}

function void newAction() {
    SeatsInPlay = sortAscending(seatsWithAction())
    if (SeatsInPlay:count() <= 1) { return }
    let Count = SeatsInPlay:count()
    
    let NextSeat = function(Current:number) {
        let Index = SeatsInPlay:indexOf(Current)
        if (!Index) {
            foreach(I:number, Seat:number = SeatsInPlay) {
                if (Seat > Current) {
                    return SeatsInPlay[I, number]
                }
            }
            return SeatsInPlay[1, number]
        }
        return SeatsInPlay[Index % Count + 1, number]
    }
    let HasActioned = function(Seat:number) {
        foreach(_:string, Player:table = Players) {
            if(Player["Seat", number] == Seat) {
                return Player["Action", number]
            }
        }
        return 0
    }
    ActionSeat = NextSeat(ActionSeat)[number]
    if(!HasActioned(ActionSeat)[number]) {
        let CurrentPlayer = playerFromSeat(ActionSeat)
        drawButtons(CurrentPlayer, ActionSeat, CurrentBet)

        let BotPlayer = playerFromSeat(ActionSeat)
        if (isBot(BotPlayer)) {
            let BotTimer = "bot_" + ActionSeat
            timer(BotTimer, 1, function() {
                botAct(ActionSeat)
                timer(1.2, function() {
                    newAction()
                })
            })
            return
        }
    }
}

# Function to progress the game
function string updateGameState() {
    GameState++
    let States = array("Pre-Flop", "Flop", "Turn", "River", "Showdown")
    let NewState = States[GameState, string]
    
    #Local helper functions
    let Header = function(Text:string) {
        return "=== " + Text + " ==="
    }
    
    let DealHand = function(Player:table) {
        for (_=1, 2) {
            let Card = Deck["draw", function]()[table]
            Player["Cards", table]:pushTable(Card)
            Player["Entity", entity]:msg("You were dealt: " + Card["toString", function]()[string])
        }
    }
    
    let CommunityToString = function() {
        let String = ""
        let Count = CommunityCards:count()
        foreach(Index:number, Card:table = CommunityCards) {
            String += Card["toString", function]()[string]
             if (Count > 1 && Index < Count) {
                String += ", "
            }
        }
        return String
    }
    
    let ResetBoard = function() {
        stoptimer("action")
        stoptimer("fold")
        
        processLeavingPlayers()
        timer(1, function() {
            foreach(_:string, Player:table = Players) {
                if (Player["Chips", number] == 0) {
                    let SeatNum = Player["Seat", number]
                    drawEmptySeat(SeatNum)
                    Players:removePlayer(SeatNum)
                }
            }
        })
        timer(5, function() {
            # Reset board
            ActionSeat = 0
            CurrentBet = 0
            Pot = 0
            InPlay = 0
            for (Seat=2, 8) {
                deleteButtons(Seat)
                deleteShowHand(Seat)
                clearHandRanks(Seat)
                deleteCurrentBet(Seat)
            }
            deleteCommunityCards()
            updatePot(Pot)

            timer(1, function() {
                if (Players:count() < 2) {
                    InPlay = 0
                    return
                }
                for (Seat=2, 8) {
                    initHand(Seat)
                }
            })

            timer(2, function() {
                if (Players:count() < 2) {
                    InPlay = 0
                    return
                }
                InPlay = 1
                GameState = 0
                updateGameState()
            })
        })
    }

    let EndRound = function() {
        foreach(_:string, Player:table = Players) {
            drawShowHandButton(Player["Seat", number])
        }
        InPlay = 0
        timer(5, function() {
            ResetBoard()
        })
    }

    let Action = function() {
        # Timer animation for Player to make a move.
        SeatsInPlay = sortAscending(seatsWithAction())
        if (SeatsInPlay:count() == 0) {
            updateGameState()
            return
        }
        if (seatsInPlay():count() <= 1) {
            if (seatsInPlay():count()) {
                ActionSeat = seatsInPlay()[1, number]
                payWinners(
                    table(
                        table("Seat" = ActionSeat, "MaxPot" = 0)
                    )
                )
            }
            EndRound()
            return
        }
        let CurrentPlayer = playerFromSeat(ActionSeat)
        if (!isBot(CurrentPlayer)) {
            drawButtons(CurrentPlayer, ActionSeat, CurrentBet)
        }
        let HasActioned = function(Seat:number) {
            foreach(_:string, Player:table = Players) {
                if(Player["Seat", number] == Seat) {
                    return Player["Action", number]
                }
            }
            return 0
        }
        let RestartTimer = function(Name:string, Delay:number, Function:function) {
            if(timerExists(Name)) {
                timerRestart(Name)
                timerAdjust(Name, Delay, 1)
            }
            else {
                timer(Name, Delay, function() {
                    Function()
                })
            }
        }
        let ActionAnimation = function() {}
        SeatsInPlay = sortAscending(seatsWithAction())
        ActionAnimation = function() {
            if (InPlay) {
                if((seatsInPlay()):count() == 1) {
                    # Insert winning logic here
                    ActionSeat = seatsInPlay()[1, number]
                    payWinners(
                        table(
                            table("Seat" = ActionSeat, "MaxPot" = 0)
                        )
                    )
                    EndRound()
                }
                elseif(!HasActioned(ActionSeat)[number]) {
                    RestartTimer("action", 16, function() {ActionAnimation()})
                    RestartTimer("fold", 15, function() {
                        foldHand(ActionSeat)
                        newAction()
                    })
                }
                else {
                    stoptimer("action")
                    stoptimer("fold")
                    updatePot(Pot)
                    updateGameState()
                }
            }
        }
        timer("action", 22, function() {
            ActionAnimation()
        })
        timer("fold", 19, function() {
            foldHand(ActionSeat)
            timer(1.2, function() {
                newAction()
            })
        })
    }

    let SetAction = function() {
        #[
        Pre-Flop
            The action starts with the player sitting to the left of the big blind.
        Post-Flop (and Subsequent Betting Rounds)
            The action starts with the player sitting to the left of the dealer button, if they are still in the hand.
        Special Cases
            In heads-up play (two players), the small blind acts first pre-flop, but the big blind acts first post-flop.
        ]#
        
        CurrentBet = 0
        foreach(_:string, Player:table = Players) {
            Player["Action", number] = 0
            Player["CurrentBet", number] = 0
        }
        for (Seat=2, 8) {
            deleteCurrentBet(Seat)
        }
        AllIn = table()
        let PreFlop = function(Sorted:array, Index:number) {
            let Count = Sorted:count()
            return Sorted[(Index + 2) % Count + 1, number]
        }
        let PostFlop = function(Sorted:array, Index:number) {
            let Count = Sorted:count()
            return Sorted[Index % Count + 1, number]
        }
        let Index = SeatsInPlay:indexOf(CoinSeat)
        let Count = SeatsInPlay:count()
        if(SeatsInPlay:count() > 2) {
            if (NewState == "Pre-Flop") {
                # Pre-Flop
                CurrentBet = MinBet
                let SmallBlind = MinBet/2
                blind(SeatsInPlay[Index % Count + 1, number], SmallBlind)
                blind(SeatsInPlay[(Index + 1) % Count + 1, number], MinBet)
                ActionSeat = PreFlop(SeatsInPlay, Index)[number]
            }
            else {
                # Post-Flop
                ActionSeat = PostFlop(SeatsInPlay, Index)[number]
            }
        }
        else {
            # Special cases
            if (NewState == "Pre-Flop") {
                # Pre-Flop
                let SmallBlind = MinBet/2
                ActionSeat = CoinSeat
                blind(ActionSeat, SmallBlind)
                blind(SeatsInPlay[Index % Count + 1, number], MinBet)
            }
            else {
                # Post-Flop
                ActionSeat = PostFlop(SeatsInPlay, Index)[number]
            }
        }
        timer(1, function() {
            Action()
        })
    }
    
    let Draw_Community = function(Num:number) {
        let Name = array("Flop1", "Flop2", "Flop3", "Turn", "River")[Num, string]
        let Card = Deck["draw", function]()[table]
                    
        CommunityCards:pushTable(Card)
        drawCommunityCard(Name, Card)
    }
    
    let Notify_Player = function(Player:table) {
        let PlayerEntity = Player["Entity", entity]
        PlayerEntity:msg(Header(NewState)[string])
        if (PlayerEntity:isValid()) {
            let Cards = CommunityToString()[string]
            if (Cards != "") {
                let EvaluatedHand = evaluateHand(Player)
                let Description = EvaluatedHand["Description", string]:lower()
                PlayerEntity:msg(Cards)
                PlayerEntity:msg("You have " + Description)
            }
        }
    }
    
    switch(NewState) {
        case "Pre-Flop",
            CommunityCards = table()
            Deck["initialize", function]()
            Deck["shuffle", function]()
            foreach(_:string, Player:table = Players) {
                Player["InPlay", number] = 1
                Player["Cards", table] = table()
                Player["TotalBet", number] = 0
                Player["CurrentBet", number] = 0
                Player["MaxPot", number] = 0
                clearHandRanks(Player["Seat", number])
                Notify_Player(Player)
                DealHand(Player)
            }
            SeatsInPlay = sortAscending(seatsInPlay())
            assignCoin()
            dealHands(SeatsInPlay)
            timer(6, function() {
                SetAction()
            })
        break
        case "Flop",
            let Num = 1
            let Deal3Cards = function() {}
            Deal3Cards = function(Num:number) {
                Draw_Community(Num)
                if (Num <= 2) {
                    Num++
                    timer(0.2, function() { Deal3Cards(Num) }) 
                    # Pass the function reference explicitly
                }
                else {
                    foreach(_:string, Player:table = Players) {
                        Notify_Player(Player)
                    }
                    SetAction()
                }
            }
            Deal3Cards(Num)
        break
        case "Turn",
        case "River",
            let Index = NewState == "Turn" ? 4 : 5
            Draw_Community(Index)
            foreach(_:string, Player:table = Players) {
                Notify_Player(Player)
            }
            SetAction()
        break
        case "Showdown",
            GameState = 0
            if(CommunityCards:count() != 5) {
                timer(1, function() {
                    updateGameState()
                })
                return ""
            }
            paySidePots()
            EndRound()
        break
        default,
        break
    }
    return NewState
}


# =================== Poker Player Functions =============== #

# Add a player to the table
function void table:addPlayer(Entity:entity, Chips:number, Seat:number) {
    let SteamID = Entity:isValid() ? Entity:steamID() : "Debug "+Seat
    This[SteamID, table] = table(
        "ID" = SteamID,
        "Entity" = Entity,
        "Cards" = table(),
        "Chips" = Chips,
        "Seat" = Seat,
        "InPlay" = 0,
        "Action" = 0,
        "TotalBet" = 0,
        "CurrentBet" = 0,
        "MaxPot" = 0
    )
    let Name = Entity:isValid() ? Entity:name() : "Debug "+Seat
    foreach(_:string, Player:table = Players) {
        Player["Entity", entity]:msg(Name + " has joined the table.")
    }
    drawPlayer(Seat, Name, Chips)
}

function table:removePlayer(Entity:entity) {
    let Name = Entity:isValid() ? Entity:name() : "Player"
    let Seat = 0
    foreach(_:string, Player:table = Players) {
        Player["Entity", entity]:msg(Name + " has left the table.")
        if (Player["Entity", entity] == Entity) {
            Seat = Player["Seat", number]
        }
    }
    if (Seat) {
        This:removeTable(Entity:steamID())
        drawEmptySeat(Seat)
    }
    else {
        owner():msg("Cannot find " + Entity:name())
    }
}

function entity getSeatEntity(SeatNumber:number) {
    foreach(_:string, Player:table = Players) {
        if (Player["Seat", number] == SeatNumber) {
            return Player["Entity", entity]
        }
    }
    return _NO_ENTITY
}

function number getSeatNumber(Entity:entity) {
    foreach(_:string, Player:table = Players) {
        if (Player["Entity", entity] == Entity) {
            return Player["Seat", number]
        }
    }
    return 0
}

function void leaveTable(Player:entity) {
    if (!Player:isValid()) { return }
    let Seat = getSeatNumber(Player)
    if (!Seat) {
        Player:msg("You are not seated.")
        return
    }
    let Steam = Player:steamID()
    let PlayerTable = Players[Steam, table]
    if (PlayerTable["InPlay", number]) {
        foldHand(Seat)
    }
    PlayerTable["Leaving", number] = 1
    Player:msg("You will leave after this round.")
}

function number joinTable(Player:entity, SeatNumber:number) {
    if (Player == _NO_ENTITY && getSeatEntity(SeatNumber) == _NO_ENTITY) {
        Players:addPlayer(Player, BuyIn, SeatNumber) # For Debug Players
        return 1
    }
    if (getSeatEntity(SeatNumber) != _NO_ENTITY) {
        return 0
    }
    if(getSeatNumber(Player)) {
        Player:msg("You are already seated.")
        return 0
    }
    Players:addPlayer(Player, BuyIn, SeatNumber)
    return 1
}

function void start() {
    if (InPlay) { return }
    if (Players:count() < 2) {
        broadcast("Waiting for more players...")
        InPlay = 0
        return
    }
    broadcast("Game starting...")
    InPlay = 1
    GameState = 0
    stoptimer("game")
    timer(3, function() {
        updateGameState()
    })
}

function void showdown() {
    let Showdown = function() {}
    Showdown = function() {
        if(updateGameState() != "Showdown") {
            timer(3, function() { 
                Showdown() 
            }) 
        }
    }
    Showdown()
}

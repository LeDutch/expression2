@name Rotating 2D Cube
@inputs EGP:wirelink
@outputs 
@persist [Vertices Edges]:table [Angle Speed]:number
@trigger 

# Function to rotate a point around the y-axis
function array rotate2D(X:number, Z:number, Angle:number) {
    let Radians = Angle * (_PI / 180)
    let NewX = X * cos(Radians) - Z * sin(Radians)
    let NewZ = X * sin(Radians) + Z * cos(Radians)
    return array(NewX+250, NewZ+250)
}

if (first()) {
    # Define cube vertices
    Vertices = table(
        array(-100, -100, -100), # Vertex 1
        array(100, -100, -100),  # Vertex 2
        array(100, 100, -100),   # Vertex 3
        array(-100, 100, -100),  # Vertex 4
        array(-100, -100, 100),  # Vertex 5
        array(100, -100, 100),   # Vertex 6
        array(100, 100, 100),    # Vertex 7
        array(-100, 100, 100)    # Vertex 8
    )
    
    # Define cube edges
    Edges = table(
        array(1, 2), array(2, 3), array(3, 4), array(4, 1), # Front face
        array(5, 6), array(6, 7), array(7, 8), array(8, 5), # Back face
        array(1, 5), array(2, 6), array(3, 7), array(4, 8)  # Connecting edges
    )
    
    # Rotation angle
    Angle = 0
    
    # Rotation speed
    Speed = 50
}

interval(100)

# Loop through each edge and draw it
let Count = Edges:count()
for (I = 1, Count) {
    let Edge = Edges[I, array]
    let StartVertex = Vertices[Edge[1,number], array]
    let EndVertex = Vertices[Edge[2,number], array]
    
    # Rotate vertices around the y-axis
    let Start = rotate2D(StartVertex[1, number], StartVertex[3, number], Angle)
    let End = rotate2D(EndVertex[1, number], EndVertex[3, number], Angle)
    
    # Draw line between rotated vertices
    EGP:egpLine(I, vec2(Start[1, number], Start[2, number]), vec2(End[1, number], End[2, number]))
    if(I<2){
        #print(vec2(Start[1, number], Start[2, number]), vec2(End[1, number], End[2, number]))
    }
    
}

# Increment rotation angle
Angle += Speed

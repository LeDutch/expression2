#include "library/tomato_lib"

function void startAnimation(TimerID:string, Dur:number) {
    Timer:setTime(TimerID,Dur)
}
function number checkAnimation(TimerID:string) {
    let Time = Timer:getTime(TimerID)
    if(Time <= 0) {
        Timer:setTime(TimerID,0)
        Animation = 0
        return 0
    }
    else {
        Timer:reduceTime(TimerID, 0.025)
        return Time - 0.025
    }
}
function number sleep(Dur:number) {
    let Time = Timer:getTime("sleep")
    if (Time == 0) {
        Timer:setTime("sleep",Dur+1)
    }
    elseif(Time == 1) {
        Animation = 0
    }
    Timer:reduceTime("sleep", 1)
    return Time
}
function number fadeIn(Element:string,YOffset:number,FadeTime:number) {
    let ID = Elements:get(Element)
    let TimerID = Element
    let Pos = EGP:egpPos(ID)
    if (!Animation) {
        startAnimation(TimerID, FadeTime)
    }
    else {
        let Time = checkAnimation(TimerID)
        EGP:egpPos(ID, vec2(Pos:x(), Pos:y()-YOffset*Time))
        EGP:egpAlpha(ID,255-255*Time/FadeTime)
        return Time
    }
    return 1
}
function number fadeOut(Element:string,YOffset:number,FadeTime:number) {
    let ID = Elements:get(Element)
    let TimerID = toString(ID)
    let Pos = EGP:egpPos(ID)
    if (!Animation) {
        startAnimation(TimerID, FadeTime)
    }
    else {
        let Time = checkAnimation(TimerID)
        if (Time >= 0.1) {
            EGP:egpPos(ID, vec2(Pos:x(), (Pos:y()+YOffset*Time)))
            EGP:egpAlpha(ID,255*Time/FadeTime)
            return Time
        }
        else {
            EGP:egpAlpha(ID,0)
            return 0
        }
    }
    return 1
}
function loadingSpinner(Element:string) {
    let ID = Elements:get(Element+"1")
    for (I=1, 12) {
        let BoxID = ID+(I-1)
        let Alpha = EGP:egpAlpha(BoxID) - 21.5
        EGP:egpAlpha(BoxID,Alpha % 255)
        
    }
}
function number moveTo(Element:string, Dur:number, Target:vector2) {
    let ID = Elements:get(Element)
    let Pos = EGP:egpPos(ID)
    if (!Animation) {
        startAnimation(Element, Dur)
    }
    else {
        let Time = checkAnimation(Element)
        if (Time >= 0.1) {
            let Direction = (Target - Pos):normalized()
            let DistancePerSecond = (Target - Pos):length() / (Dur*5)
            let AnimatedPos = Pos + Direction * DistancePerSecond
            EGP:egpPos(ID, AnimatedPos)
            return Time
        } else {
            EGP:egpPos(ID, Target)
            return 0
        }
    }
    return 1
}
function typeOut(Element:string, Word:string) {
    let ID = Elements:get(Element)
    let TimerID = Element
    let Length = Word:length()
    if (!Animation) {
        startAnimation(TimerID, Length / 10)
    }
    else {
        let Time = checkAnimation(TimerID)
        let Index = Length - Time*10+1
        EGP:egpSetText(ID, Word:sub(1, Index))
    }
}

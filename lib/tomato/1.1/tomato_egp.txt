@name Tomato EGP 1.1
@persist Elements:table CurrentUser:entity Precached:array
@inputs EGP:wirelink User:entity
@strict

#[ =================== G'day ============================ #
 Coded by Bob Tomato, feel free to add me :) 
 Steam: https://steamcommunity.com/id/iamthedutchman/
 Discord: le.dutch
 To compile graphics: https://www.egpcompiler.com/
]#

#[ =================== To DO ============================ #
 - EGP Compiler parenting system
 - EGP Compiler transition system
]#

if (first()) {
    # Initialize variables
    Elements = table()
    Precached = array()
    CurrentUser = _NO_ENTITY
    if(CurrentUser) {}
}

# =================== Parenting Functions ================= #

# EGP Objects
function void egpobject:giveParent(Parent:egpobject) {
    # This == Child
    const Pos = vec2(This["x", number], This["y", number])
    const ParentPos = vec2(Parent["x", number], Parent["y", number])
    const NewPos = (Pos - ParentPos):normalized()*ParentPos:distance(Pos)
    This["x", number] = NewPos:x()
    This["y", number] = NewPos:y()
    This:parentTo(Parent)
}

function void egpobject:giveChild(Child:egpobject) {
    # This == Parent
    const Pos = vec2(This["x", number], This["y", number])
    const ChildPos = vec2(Child["x", number], Child["y", number])
    const NewPos = (ChildPos - Pos):normalized()*Pos:distance(ChildPos)
    Child["x", number] = NewPos:x()
    Child["y", number] = NewPos:y()
    Child:parentTo(This)
}

# ID System
function void number:giveParent(ParentID:number) {
    const Parent = EGP:egpobject(ParentID)
    const Child = EGP:egpobject(This)
    Child:giveParent(Parent)
}

function void number:giveChild(ChildID:number) {
    const Child = EGP:egpobject(ChildID)
    const Parent = EGP:egpobject(This)
    Parent:giveChild(Child)
}

# Combined for graphic funcs
function void number:giveChild(Child:egpobject) {
    const Parent = EGP:egpobject(This)
    Parent:giveChild(Child)
}

# =================== Graphic Functions =================== #

function number initial() {
    return ->EGP && (first() || dupefinished() || ~EGP)
}

function number table:get(...Args:array) {
    const Name = Args[1, string]
    if (Name) {
        if (This:exists(Name)) {
            return This[Name, number]   
        }
        const FreeID = This:flip():ncount()+1
        This[Name, number] = FreeID
        return FreeID
    }
    const FreeID = This:flip():ncount()+1
    This[toString(FreeID), number] = FreeID
    return FreeID
}

function void wirelink:clear() {
    This:egpClear()
    Elements:clear()
}

function void wirelink:delArray(Arr:array) {
    foreach(_:number, Item:string = Arr) {
        This:egpRemove(Elements:get(Item))
    }
}

function void wirelink:delete(...Arr:array) {
    foreach(_:number, Item:string = Arr) {
        This:egpRemove(Elements:get(Item))
    }
}

function egpobject text(Name:string, Args:table) {
    const ID = (Name) ? Elements:get(Name) : Elements:get()
    const RGB = Args["rgb", vector]
    
    if (RGB) {
        Args["r", number] = RGB:x()
        Args["g", number] = RGB:y()
        Args["b", number] = RGB:z()
    }
    
    const Object = EGP:egpTextLayout(ID, Args)
    const Parent = Args["parent", string]

    if (Parent) {
        Elements:get(Parent):giveChild(Object)
    }
    return Object
}
function egpobject text(Args:table) {
    return text("", Args)
}

function egpobject stext(Name:string, Args:table) {
    const ID = (Name) ? Elements:get(Name) : Elements:get()
    const RGB = Args["rgb", vector]
    
    if (RGB) {
        Args["r", number] = RGB:x()
        Args["g", number] = RGB:y()
        Args["b", number] = RGB:z()
    }
    
    const Object = EGP:egpText(ID, Args)
    const Parent = Args["parent", string]
    
    if (Parent) {
        Elements:get(Parent):giveChild(Object)
    }
    return Object
}
function egpobject stext(Args:table) {
    return text("", Args)
}

function egpobject circle(Name:string, Args:table) {
    const ID = Elements:get(Name)
    const Parent = Args["parent", string]
    const Object = Args["outline", number] ? EGP:egpCircleOutline(ID, Args) : EGP:egpCircle(ID, Args)
    const RGB = Args["rgb", vector]
    
    if (RGB) {
        Args["r", number] = RGB:x()
        Args["g", number] = RGB:y()
        Args["b", number] = RGB:z()
    }
    
    if (Parent) {
        Elements:get(Parent):giveChild(Object)
    }
    return Object
}
function egpobject circle(Args:table) {
    return circle("", Args)
}

function egpobject box(Name:string, Args:table) {
    const ID = Elements:get(Name)
    const Outline = Args["outline", number]
    const Radius  = Args["radius", number]
    
    const Parent = Args["parent", string]
    const Material = Args["material", string]
    const Precache = Args["precache", string]
    
    const RGB = Args["rgb", vector]
    
    if (RGB) {
        Args["r", number] = RGB:x()
        Args["g", number] = RGB:y()
        Args["b", number] = RGB:z()
    }
    
    let Object = noegpobject()

    if (!Outline & !Radius) {
        Object = EGP:egpBox(ID, Args)
    } elseif (Outline & Radius) {
        Object = EGP:egpRoundedBoxOutline(ID, Args)
    } elseif (Outline) {
        Object = EGP:egpBoxOutline(ID, Args)
    } else {
        Object = EGP:egpRoundedBox(ID, Args:add(table("fidelity"=50)))
    }

    if (Parent) { Elements:get(Parent):giveChild(Object) }
    
    if (Precache) {
        #ifdef tauPrecacheMaterial(String)
            tauPrecacheMaterial(Precache)
            timer(_TICKINTERVAL, function() {
                Object["material", string] = Material
            })
            Precached:pushEgpobject(Object)
        #else
            print("This E2 uses a webmat on TAU which has not been loaded")
            print(String)
        #endif
    }
    
    return Object
}

function egpobject box(Args:table) {
    return box("", Args)
}

function egpobject poly(Name:string, Args:table) {
    const ID = (Name) ? Elements:get(Name) : Elements:get()
    const Parent = Args["parent", string]
    const Verts = Args["vertices", array]
    const Outline = Args["outline", number]
    
    let Object = Outline ? EGP:egpPolyOutline(ID, Args) : EGP:egpPoly(ID, Args)
    Object:setVertices(Verts)
    if (Parent) {
        ID:giveChild(Object)
    }
    return Object
}
function egpobject poly(Args:table) {
    return poly("", Args)
}

function void opacity(Name:string, Value:number) {
    const ID = Elements:get(Name)
    EGP:egpAlpha(ID, Value)
}

# =================== Interaction Functions =============== #

function number userInput() {
    const Pressed = ~User && User:isValid()
    if (Pressed) {
        CurrentUser = User
    }
    return Pressed
}
function number userInput(Player:entity) { # Check for specific player input
    return ~User && Player:isValid()
}

# Check all egp objects on screen - checks in reverse to reduce lag but will require ops if many objects
function string cursorObj(User:entity) {
    const Cursor = EGP:egpCursor(User)
    const Objects = EGP:egpObjectIndexes()
    const Names = Elements:flip()

    # Helper function to find the topmost parent of an object
    const FindTopParent = function(Object:egpobject, Index:number) {
        while (Object:parentIndex()) {
            Index = Object:parentIndex()
            Object = EGP:egpobject(Index)
        }
        return Index
    }

    # Iterate through objects in reverse order
    for (I = Objects:count(), 1, -1) {
        const ID = Objects[I, number]
        
        # Skip 'blank' numeric names
        if (Names[ID, number] > 1) {
            continue
        }

        # Check if the object contains the cursor
        const Object = EGP:egpobject(ID)
        if (Object:containsPoint(Cursor)) {
            return Names[FindTopParent(Object, ID)[number], string]
        }
    }

    return ""
}

function string cursorObj() {
    return cursorObj(User)
}

# Checks an array of ONLY given object names - more efficient but doesn't check parents.

function string cursorObj(Names:array) {
    const Cursor = EGP:egpCursor(User)
    # Iterate through objects
    for (I = 1, Names:count()) {
        const ID = Elements:get(Names[I, string])
        const Object = EGP:egpobject(ID)
        if (Object:containsPoint(Cursor)) {
            return Names[I, string]
        }
    }

    return ""
}

if (initial()) {
    EGP:egpClear()
    EGP:egpDrawTopLeft(1)
}

# Webmats - is also done in the regular box() function. LEGACY
function void preCache(String:string, Object:egpobject) {
     #ifdef tauPrecacheMaterial(String)
        let Material = Object["material", string]
        tauPrecacheMaterial(String)
        timer(_TICKINTERVAL, function() {
            Object["material", string] = Material
        })
        Precached:pushEgpobject(Object)
    #else
        print("This E2 uses a webmat on TAU which has not been loaded")
        print(String)
    #endif
}

event playerSpawn(Player:entity) { 
    if(Player:deaths() == 0){
        foreach(_:number, Object:egpobject = Precached) {
            let Material = Object["material", string]
            Object["material", string] = Material
        }
    }
}

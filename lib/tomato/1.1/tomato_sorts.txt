@name Tomato Sorts

# ==================== Array Functions ================== #

function array quickSort(Array:array) {
    # Base case: if the array has 0 or 1 elements, it is already sorted
    if (Array:count() <= 1) {
        return Array
    }

    # Choose a pivot element (we'll take the first element)
    const Pivot = Array[1, number]
    let Left = array()   # Elements less than the pivot
    let Right = array()  # Elements greater than or equal to the pivot

    # Partition the array
    for (I = 2, Array:count()) {
        if (Array[I, number] < Pivot) {
            Left:pushNumber(Array[I, number])
        } else {
            Right:pushNumber(Array[I, number])
        }
    }

    # Recursively sort the left and right partitions and combine them
    return quickSort(Left):add(array(Pivot)):add(quickSort(Right))
}

# ==================== Table Functions ================== #

# This is a bubble sort - slight worse ops 
function string table:sortByKeys() {
    let Text = ""
    let Keys = This:keys()
    let Values = This:values()
    for (I = 1, This:count()) {
        for (J = 1, This:count() - I) {
            if (Values[J,number] > Values[J+1,number]) {
                # Swap elements if they are out of order
                let TempKey = Keys[J, string]
                let Temp = Values[J, number]
                Values[J, number] = Values[J + 1, number]
                Values[J + 1, number] = Temp
                Keys[J, string] = Keys[J+1, string]
                Keys[J + 1, string] = TempKey
            }
        }
    }
    for (I=1, This:count()) {
        Text += (Keys[I, string] + " = " + Values[I, number] + "% \n")
    }
    return Text
}

# ==================== Casino Functions ================= #

function array calcOddsWithHouseEdge(Multipliers:array, HouseEdge:number) {
    let Probabilities = array()
    let TotalMultipliers = 0
        
    # Step 1: Calculate the total sum of all multipliers
    for (I = 1, Multipliers:count()) {
        TotalMultipliers += Multipliers[I, number]
    }
        
    # Step 2: Calculate the player return (100% - HouseEdge)
    let PlayerReturn = 1 - HouseEdge
        
    # Step 3: Calculate the probability for each multiplier
    for (I = 1, Multipliers:count()) {
        let ExpectedReturn = PlayerReturn / TotalMultipliers
        let Probability = ExpectedReturn / Multipliers[I, number]
        Probabilities:pushNumber(Probability)
    }
        
    # Normalize to make sure all probabilities add up to 1
    let TotalProbabilities = 0
    for (I = 1, Probabilities:count()) {
        TotalProbabilities += Probabilities[I, number]
    }
        
    for (I = 1, Probabilities:count()) {
        Probabilities[I, number] = Probabilities[I, number] / TotalProbabilities
    }
        
    return Probabilities
}

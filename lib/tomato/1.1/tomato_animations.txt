@name Tomato Animations
@persist HoverElements:table

#include "lib/tomato/1.1/tomato_egp"

if (first()) {
    HoverElements = table()
}

# ==================== Animation Core ==================== #

function number easeBilinear(T:number) {
    T = clamp(T, 0, 1)
    return (T < 0.5) ? (2 * T * T) : (1 - 2 * (1 - T) * (1 - T))
}

function number repeats(Dur:number) {
    return max(1, ceil(Dur / tickRealInterval()))
}

function void startAnimation(Name:string, Func:function, Dur:number) {
    Func() # Start immediately
    timer(Name, tickRealInterval(), repeats(Dur)-1, function() {
        Func()
    })
}

function void stopAnimation(Name:string) {
    stoptimer(Name)
}

function void fadeIn(Name:string, Dur:number) {
    let Object = EGP:egpobject(Elements:get(Name))
    let Repeats = repeats(Dur)
    Object["a", number] = 0
    let Animation = function() {
        Object["a", number] = Object["a", number] + 255/Repeats
    }
    startAnimation(Name+"_fadein", Animation, Dur)
}

function void fadeOut(Name:string, Dur:number) {
    let Object = EGP:egpobject(Elements:get(Name))
    let Repeats = repeats(Dur)
    Object["a", number] = 255
    let Animation = function() {
        Object["a", number] = Object["a", number] - 255/Repeats
    }
    startAnimation(Name+"_fadeout", Animation, Dur)
}

function void moveTo(Name:string, Dur:number, Target:vector2) {
    let ID = Elements:get(Name)
    
    let Object = EGP:egpobject(ID)
    let Pos = EGP:egpPos(ID)
    
    let Direction = (Target - Pos):normalized()
    let Distance = Target:distance(Pos)
    let Repeats = repeats(Dur)
    
    let StepX = Direction:x()*Distance/Repeats
    let StepY = Direction:y()*Distance/Repeats
    
    let Animation = function() {
        Object["x", number] = Object["x", number] + StepX
        Object["y", number] = Object["y", number] + StepY
    }
    startAnimation(Name+"_move", Animation, Dur)
}

function void rotateTo(Name:string, Dur:number, Angle:number) {
    let ID = Elements:get(Name)
    let Object = EGP:egpobject(ID)
    let Distance = Angle - Object["angle", number]
    let Step = Distance/repeats(Dur)
    let Animation = function() {
        Object["angle", number] = Object["angle", number] + Step
    }
    startAnimation(Name+"_rotate", Animation, Dur)
}

function void transform(Name:string, Dur:number, TargetSize:vector2) {
    let ID = Elements:get(Name)
    let Object = EGP:egpobject(ID)
    let Size = EGP:egpSize(ID)
    let WDist = TargetSize:x() - Size:x()
    let HDist = TargetSize:y() - Size:y()
    let Repeats = repeats(Dur)
    let Animation = function() {
        Object["w", number] = Object["w", number] + WDist/Repeats
        Object["h", number] = Object["h", number] + HDist/Repeats
    }
    startAnimation(Name+"_transform", Animation, Dur)
}

function void typeOut(Name:string, Word:string) {
    let Object = EGP:egpobject(Elements:get(Name))
    let Length = Word:length()
    
    let Index = 1
    
    let Animation = function() {
        if (Index <= Length) {
            Object["text", string] = Object["text", string] + Word[Index]
            Index++
        }
        else {
            stopAnimation(Name+"_type")
        }
    }

    startAnimation(Name+"_type", Animation, Length)
}

function void colourTo(Name:string, Dur:number, Target:vector) {
    let Object = EGP:egpobject(Elements:get(Name))
    let R = Object["r", number]
    let G = Object["g", number]
    let B = Object["b", number]
    
    let RGB = vec(R,G,B) 
    let Steps = repeats(Dur)
    let Step = 0
    
    let Animation = function() {
        let T = clamp(Step / Steps, 0, 1)
        RGB += (Target - RGB) * T
        Step++

        Object["r", number] = RGB:x()
        Object["g", number] = RGB:y()
        Object["b", number] = RGB:z()
    }
    startAnimation(Name+"_colourTo", Animation, Dur)
}

function void hoverColour(Name:string, Dur:number, Colour:vector) {
    if (!HoverElements[Name, table]) {
        let ID = Elements:get(Name)
        let Object = EGP:egpobject(ID)
        let Params = EGP:egpCopy(Elements:get(), Object)
        Params["a", number] = 0
        Params["x", number] = -512
        Params["y", number] = -512
        HoverElements[Name, table] = 
            table(
                "ID" = ID,
                "Name" = Name,
                "Object" = Object,
                "Params" = Params
            )
    }
    HoverElements[Name, table]["TargetColour", vector] = Colour
    if (!timerExists("hoverCheck")) {
        timer("hoverCheck", 0.1, 0, function() {
            let Cursor = EGP:egpCursor(CurrentUser)
            foreach(_:string, Element:table = HoverElements) {
                let Name = Element["Name", string]
                let Object = Element["Object", egpobject]
                if (Object:containsPoint(Cursor)) {
                    let R = Object["r", number]
                    let G = Object["g", number]
                    let B = Object["b", number]
                    
                    let RGB = vec(R,G,B)
                    let Target = HoverElements[Name, table]["TargetColour", vector]
                    if (RGB != Target && !timerExists(Name+"_colourTo") && !timerExists(Name+"_colourToPause")) {  
                        colourTo(Name, Dur, Target)
                        timer(Name+"_colourToPause", 9999, function() { 
                            # Do Nothing
                        })
                    }
                    break
                }
                elseif(timerExists(Name+"_colourToPause")) {
                    stoptimer(Name+"_colourToPause")
                    
                    let Params = Element["Params", egpobject]
                    let R = Params["r", number]
                    let G = Params["g", number]
                    let B = Params["b", number]
                    
                    let RGB = vec(R,G,B)
                    
                    if (timerExists(Name+"_colourTo")) {
                        stoptimer(Name+"_colourTo")
                    }
                    colourTo(Name, Dur, RGB)
                    
                }
            }
        })
    }
}

function void glitchText(Name:string, Dur:number) {
    let ID = Elements:get(Name)
    let Object = EGP:egpobject(ID)
    let Charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/\\"
    let Final = Object["text", string]
    let Current = ""
    let Max = repeats(Dur)
    let Count = 0

    let Animation = function() {
        Current = ""
        Count++
        if (Count == Max) {
            Current = Final
        }
        else {
            for (I = 1, Final:length()) {
                if (randint(0, 1)) {
                    Current += Charset[randint(1, Charset:length())]
                } else {
                    Current += Final[I]
                }
            }
        }
        Object["text", string] = Current
    }

    startAnimation(Name+"_glitch", Animation, Dur)
}



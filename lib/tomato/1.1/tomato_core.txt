@name Tomato Core
@persist [Prefix PrefixColour]:string Functions:table 

if (first() || dupefinished()) {
    # Initialize variables
    Prefix = "E2"
    PrefixColour = "!#d4af37"
    Functions = table()
    if (Prefix) {}
    if (PrefixColour) {}
    
    entity():setSubMaterial(1, "zerochain/props_mining/zrms_goldbar")
    entity():setSubMaterial(2, "zerochain/props_mining/zrms_goldbar")
    entity():setColor(vec(255,255,255))
}

#[ =================== Messaging ========================= #
 The below two functions are for a messaging system. 
 You can modify the syntax depending on the server you are playing on.
]#

function void entity:msg(Text:string) {
    if (!This:isValid()) {return}
    #ifdef e:tauSendChatMsg(s)
        This:tauSendChatMsg("{" + PrefixColour + " " + Prefix + "}: " + Text)
    #else
        print(Text)
    #endif
}

function void entity:advert(Text:string) {
    if (!This:isValid()) {return}
    concmd("say /advert {" + PrefixColour + " " + Prefix + "}: " + Text)
}

function void array:msgAll(Text:string) {
    foreach (_:number, Player:entity = This) {
        if (Player:isValid()) {
            #ifdef e:tauSendChatMsg(s)
                Player:tauSendChatMsg("{" + PrefixColour + " " + Prefix + "}: " + Text)
            #else
                print(Text)
            #endif
        }
    }
}

# ==================== Player functions ================== #

function entity string:findPlayer() {
    return This:sub(1, 5):upper() == "STEAM" ? findPlayerBySteamID(This) : findPlayerByName(This)
}

function number isPlayerNearby(Radius:number) {
    if(findCanQuery()) {
        findIncludeClass("player")
        findInSphere(entity():pos(), Radius)
        if (findToArray():count()) {
            return 1
        }
    }
    return 0
}

function number isPlayerNearby(Player:entity, Radius:number) {
    return Player:pos():distance(entity():pos()) < Radius
}

function number isPlayerNearbyToEnt(Player:entity, Radius:number, Entity:entity) {
    return Player:pos():distance(Entity:pos()) < Radius
}

# Function to get the names of a given array of players
function array array:getPlayerNames() {
    let Array = array()
    for (I = 1, This:count()) {
        Array:pushString(This[I,entity]:name())
    }
    return Array
}

# ==================== Number functions ================== #

function string abbreviateNum(Number:number) {
    if (Number >= 1000000) {
        return round(Number / 1000000, 2) + "M"
    }
    if (Number >= 1000) {
        return round(Number / 1000, 2) + "K"
    }
    return toString(round(Number))
}


# ==================== String functions ================== #

function number string:startsWith(String:string) {
    return This:left(String:length()) == String
}

function number array:findString(E:string) {
    for (I = 1, This:count()) {
        if (This[I, string] == E) {return I}
    }
    return 0
}

function number table:findString(E:string) {
    for (I = 1, This:count()) {
        if (This[I, string] == E) {return I}
    }
    return 0
}

function string string:removeText(Text:string) {
    if (Text == "") { return This } # Avoid infinite loop with empty substring

    let Result = This
    while (Result:find(Text) != -1) { # Continue until the substring is no longer found
        let StartIndex = Result:find(Text) # Find the starting position of the substring
        let Before = Result:sub(1, StartIndex - 1) # Part of the string before the substring
        let After = Result:sub(StartIndex + Text:length()) # Part of the string after the substring
        Result = Before + After # Concatenate the two parts
    }
    return Result
}


function string truncate(Text:string, Chars:number) {
    if (Text:length() > Chars) {
        Text = Text:sub(1, Chars-3) + "..."
    }
    return Text
}

# ==================== Time functions ==================== #

function number isLeap(Y:number) {
    if (Y % 400 == 0) { return 1 }
    if (Y % 100 == 0) { return 0 }
    return (Y % 4 == 0)
}

# Add a delta (weeks/days/hours/minutes/seconds) to a dateUTC() table
function table dateAdd(Date:table, Delta:table) {
    # copy fields we care about
    let R = table(
        "year" = Date["year", number],
        "month" = Date["month", number],
        "day" = Date["day", number],
        "hour" = Date["hour", number],
        "min" = Date["min", number],
        "sec" = Date["sec", number]
    )

    # read delta components (missing keys default to 0)
    let DSec  = Delta["seconds", number]
    let DMin  = Delta["minutes", number]
    let DHour = Delta["hours", number]
    let DDay  = Delta["days", number]
    let DWeek = Delta["weeks", number]

    # convert everything to seconds
    let AddSec = DSec
        + DMin  * 60
        + DHour * 3600
        + DDay  * 86400
        + DWeek * 604800

    # apply seconds
    R["sec", number] = R["sec", number] + AddSec

    # normalize sec → min
    R["min", number] = R["min", number] + floor(R["sec", number] / 60)
    R["sec", number] = R["sec", number] % 60

    # normalize min → hour
    R["hour", number] = R["hour", number] + floor(R["min", number] / 60)
    R["min", number] = R["min", number] % 60

    # normalize hour → day
    R["day", number] = R["day", number] + floor(R["hour", number] / 24)
    R["hour", number] = R["hour", number] % 24

    # month lengths
    let MonthDays = array(
        0,
        31,
        28 + isLeap(R["year", number]),
        31,30,31,30,
        31,31,30,31,30,31
    )

    # normalize day → month/year
    while (R["day", number] > MonthDays[R["month", number], number]) {
        R["day", number] = R["day", number] - MonthDays[R["month", number], number]
        R["month", number] = R["month", number] + 1
        if (R["month", number] > 12) {
            R["month", number] = 1
            R["year", number] = R["year", number] + 1
            MonthDays[2, number] = 28 + isLeap(R["year", number])
        }
    }

    return R
}

# Convenience: add to "now" (UTC)
function table dateNowAdd(Delta:table) {
    return dateAdd(dateUTC(), Delta)
}

function string getDate() {
    let Date = dateUTC()
    return toString(Date["day", number])+"/"+toString(Date["month", number])+"/"+toString(Date["year", number])
        
}

function toEpochUtc(T:table)
{
    local MonthDays = array(12)
    MonthDays[1] = 31
    MonthDays[2] = 28
    MonthDays[3] = 31
    MonthDays[4] = 30
    MonthDays[5] = 31
    MonthDays[6] = 30
    MonthDays[7] = 31
    MonthDays[8] = 31
    MonthDays[9] = 30
    MonthDays[10] = 31
    MonthDays[11] = 30
    MonthDays[12] = 31

    local Y = T["year", number]
    local M = T["month", number]
    local D = T["day", number]
    local H = T["hour", number]
    local Min = T["min", number]
    local S = T["sec", number]

    local Days = (Y - 1) * 365 + floor((Y - 1) / 4) - floor((Y - 1) / 100) + floor((Y - 1) / 400)

    local IsLeap = (Y % 4 == 0 & Y % 100 != 0) | (Y % 400 == 0)
    if (IsLeap) { MonthDays[2] = 29 }

    for(I = 1, M - 1) { Days += MonthDays[I, number] }

    Days += D - 1

    local Total = Days * 86400 + H * 3600 + Min * 60 + S
    return Total
}

function string formatTimeInHours(Number:number) {
    if (Number >= 24) {
        return round(Number / 24, 2) + " days"
    }
    if (Number >= 1) {
        return round(Number, 2) + (Number > 1 ? " hrs" : " hr")
    }
    return round(Number * 60, 2) + (Number > 0.1 ? " mins" : " min")
}

function string formatTimeInSeconds(Number:number) {
    if (Number > 60) {
        return round(Number / 60, 2) + " mins"
    }
    if (Number == 60) {
        return "1 min"
    }
    return Number + (Number == 1 ? " sec" : " secs")
}

function hoursBetween(A:table, B:table)
{
    local Secs = toEpochUtc(B) - toEpochUtc(A)
    return round(Secs / 3600, 2)
}

# ==================== Array functions =================== #


function array array:reverse() {
    let Temp = array()
    for (I = This:count(), 1, -1) {
        Temp:pushNumber(This[I, number])
    }
    return Temp
}

function number array:exists(A:string) {
    for (I = 1, This:count()) {
        if (This[I, string] == A) {
            return 1
        }
    }
    return 0
}

function number array:exists(A:entity) {
    for (I = 1, This:count()) {
        if (This[I, entity] == A) {
            return 1
        }
    }
    return 0
}

function number array:numExists(A:number) {
    # default func array:exists(num) is a dumb function that returns if any value exists
    for (I = 1, This:count()) {
        if (This[I, number] == A) {
            return 1
        }
    }
    return 0
}

function array array:intersect(B:array) {
    let Out = array()
    for (I = 1, This:count()) {
        let V = This[I, string]
        if (B:exists(V)) {
            Out:pushString(V)
        }
    }
    return Out

}


function string array:implode(Delimiter:string) {
    let Result = ""
    for (I = 1, This:count()) {
        Result += This[I, string]
        if (I < This:count()) {
            Result += Delimiter
        }
    }
    return Result
}

# ==================== Chat functions ==================== #

function chat(Command:string, Func:function, ...Players:array) {
    Functions[Command, table] = table(
        "Function" = Func,
        "Players" = Players
    )
}

function chat(Command:string, Description:string, Func:function, ...Players:array) {
    Functions[Command, table] = table(
        "Function" = Func,
        "Description" = Description,
        "Players" = Players
    )
}

event chat(Player:entity, Message:string, _:number) {
    if (Message[1] == "!") {
        let Args = Message:sub(2):explode(" ")
        let Command = Args:shiftString():lower()
        if (Functions:exists(Command)) {
            let Function = Functions[Command, table]
            let Users = Function["Players", array]
            if (Users:exists(Player) || !Users:count()) {
                Function["Function", function](Player, Args)
            }
        }
        elseif(Player == owner() && Command == "help") {
            foreach(_:string, Function:table = Functions) {
                let Description = Function["Description", string]
                Player:msg(Description)
            }
        }
    }
}


